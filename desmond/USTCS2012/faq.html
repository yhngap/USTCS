<!DOCTYPE html>
<html lang="en-US">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width" />
      <title>COMP 2012 Object-Oriented Programming and Data Structures (Supplementary Site)</title>
      <meta name="description" content="Download free amazing responsive Fashion Blog template."/>
      <meta name="keywords" content="free, responsive, blog, fashion"/>
      <link rel="stylesheet" href="css/components.css">
      <link rel="stylesheet" href="css/responsee.css">
      <!-- CUSTOM STYLE -->       
      <link href='https://fonts.googleapis.com/css?family=Roboto:400,100,300,700&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
      <link rel="stylesheet" href="css/template-style.css">
      <script type="text/javascript" src="js/jquery-1.8.3.min.js"></script>
      <script type="text/javascript" src="js/jquery-ui.min.js"></script>    
      <script type="text/javascript" src="js/modernizr.js"></script>
      <script type="text/javascript" src="js/responsee.js"></script>	  
      <script src = "https://code.jquery.com/jquery-1.10.2.js"></script>
      <script src = "https://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>
		
      <script>
         $(function() {
			$( "#tabs" ).tabs();
		 });
      </script>
	  
      <!--[if lt IE 9]> 
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script> 
      <![endif]-->     
   </head>
   <body class="size-1140">      
      <header class="margin-bottom">
         <div class="line">
            <nav>
               <div class="top-nav">
                  <p class="nav-text"></p>
                  <a class="logo" href="index.html">            
                  COMP 2012 <span>Object-Oriented Programming and Data Structures</span> (Fall 2020)
                  </a><br/>
                  <h1 style="margin-left:10px; margin-right:10px">Supplementary Site</h1>                  
               </div>
            </nav>
         </div>
      </header>
	  
      <section id="article-section" class="line">
         <div class="margin">
            <div class="s-12 l-9">               
               <article class="margin-bottom">
                  <div class="post-1 line">                     
                     <div class="s-12 l-11 post-image">                   
                        <img src="img/post4-big.jpg" alt="Fashion">              
                     </div>                     
                  </div>
                  <div class="post-text">
                     <h1>Frequently Asked Questions</h1>
					 <br/>					 
					 <div id="tabs">
						<ul style="list-style-type:circle">
							<!--<li><a href="#tabs-0">Introduction</a><div style="text-align:right"><span style="color:red">(Last update: 1 February 2018)</span></div></li>-->
							
							<li><a href="faq.html#tabs-1">Basics of C++</a> <div style="text-align:right"><span style="color:red">(Last update: 27 September 2016)</span></div>
							<li><a href="faq.html#tabs-2">Pointers, references, memory allocation and de-allocation</a> <div style="text-align:right"><span style="color:red">(Last update: 1 March 2020)</span></div></li>
							<li><a href="faq.html#tabs-3">Classes and objects</a> <div style="text-align:right"><span style="color:red">(Last update: 8 March 2018)</span></div></li>
							<li><a href="faq.html#tabs-4">Separate compilation and makefile</a> <div style="text-align:right"><span style="color:red">(Last update: 12 February 2016)</span></div></li>
							<li><a href="faq.html#tabs-5">Constructors, initialization and destructor</a> <div style="text-align:right"><span style="color:red">(Last update: 3 November 2016)</span></div></li>
							<li><a href="faq.html#tabs-6">Inheritance</a> <div style="text-align:right"><span style="color:red">(Last update: 19 March 2018)</span></div></li>
							<li><a href="faq.html#tabs-7">Runtime checking</a> <div style="text-align:right"><span style="color:red">(Last update: 16 March 2017)</span></div<</li>
							<li><a href="faq.html#tabs-8">Virtual functions and polymorphism</a> <div style="text-align:right"><span style="color:red">(Last update: 20 March 2016)</span></div></li>
							<li><a href="faq.html#tabs-9">Abstract Base Class (ABC)</a> <div style="text-align:right"><span style="color:red">(Last update: 19 March 2016)</span></div></li>
							<li><a href="faq.html#tabs-10">Type casting</a> <div style="text-align:right"><span style="color:red">(Last update: 16 March 2017)</span></div></li>
							<li><a href="faq.html#tabs-11">Operator overloading</a> <div style="text-align:right"><span style="color:red">(Last update: 28 March 2018)</span></div></li>
							<li><a href="faq.html#tabs-16">Function template and class template</a> <div style="text-align:right"><span style="color:red">(Last update: 4 November 2016)</span></div></li>
							<li><a href="faq.html#tabs-12">Friend classes and friend functions</a> <div style="text-align:right"><span style="color:red">(Last update: 7 April 2016)</span></div></li>
							<li><a href="faq.html#tabs-13">Standard Template Library</a> <div style="text-align:right"><span style="color:red">(Last update: 22 April 2016)</span></div></li>
							<li><a href="faq.html#tabs-14">Namespace</a> <div style="text-align:right"><span style="color:red">(Last update: 22 April 2016)</span></div></li>
							<li><a href="faq.html#tabs-15">Static data members and member functions</a> <div style="text-align:right"><span style="color:red">(Last update: 4 November 2016)</span></div></li>
						</ul>
					 <br/>
					 <br/>
					 <!--<div id="tabs-0">
					 <h4 style="color:darkred; font-weight:bold">Introduction</h4><br/><br/>
					 <p>		
						<ul>
							<li><div style="font-weight: 500;">Date: 1 February 2018 (Thursday)<br/><br/><span style="text-decoration:underline">What is the difference between functions and procedures?</span></div><br/>
							Generally speaking, a function always returns a value using the return statement, but a procedure is not. In C++, "functions" (those we have been using in COMP2011) actually do both, i.e. if the return type of the functions is void, they serve as procedures, otherwise they serve as functions.
							<br/><br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
							
							<li><div style="font-weight: 500;">Date: 7 September 2016 (Wednesday)<br/><br/><span style="text-decoration:underline">What is the use of the keyword "repeat" in C++?</span></div><br/>
							"repeat" is not a keyword in C++, but a keyword in Pascal. "repeat" is mentioned on page 5 because we are talking about procedural programming there. We also mention Pascal on that page. :)
							<br/><br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>					
							<li><div style="font-weight: 500;">Date: 7 September 2016 (Wednesday)<br/><br/><span style="text-decoration:underline">What is the corresponding keyword of "gosub" that shares the same (or similar) functionality in C++?</span><br/><span style="color:red">(Unrelated to the current set of lecture notes.)</span></div><br/>
							gosub in spaghetti code is similar to function call in C++.
							<br/><br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 7 September 2016 (Wednesday)<br/><br/><span style="text-decoration:underline">What do "GOTOs" mean? What are "unstructured" branching constructs? Why are they "unstructured"?</span><br/><span style="color:red">(Unrelated to the current set of lecture notes.)</span></div><br/>
							goto is a statement which provides an unconditional jump to a labeled statement. For instance, goto 100 means jump to the line with label "100". <br/><br/>
							"unstructured" branching constructs on page 3 refers to statements like						if y > 120 goto 60<br/><br/>
							We said that they are unstructured as those statements could change the flow of program drastically, e.g., can execute a line of code far below the current line, or far above the current line. Comparing goto with for, while, and do-while, you could easily realize why goto is highly unstructured.
							<br/><br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 7 September 2016 (Wednesday)<br/><br/><span style="text-decoration:underline">What are the differences between "g++", "gcc", and "gnu"?Are g++ and gcc categorized into GNU?</span></div><br/>
							Both gcc and g++ are compilers of GNU compiler collection. The differences between them are explained as follows:
							<ul>
								<li>gcc will compile .c and .cpp files as C and C++ respectively</li>
								<li>g++ will compile .c and .cpp files as well, but all will be treated as C++ files</li>
								<li>When g++ is used, it links the object files automatically with the standard C++ libraries (gcc doesn’t do this)(More on this will be elaborated in class)</li>		
							</ul>
							<br/><br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							</li>							
						</ul>
					 </p>
					 </div>-->
					 
					 <div id="tabs-1">
					 <h4 style="color:darkred; font-weight:bold">Basics of C++</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 27 September 2016 (Tuesday)<br/><br/><span style="text-decoration:underline">Printing Output of ASCII Arithmetic</span></div><br/>
							How can there be a different output for the two sets of code below?
							<br/><br/>
							<pre style="margin-left:-450px">
								#include <iostream>
								using namespace std;								
								int main() {
								  // Set 1
								  char x = 65;
								  char v = x - 'A' + 'a';
								  cout << v;  // Output is a
								  
								  // Set 2
								  x = 65;
								  cout << x - 'A' + 'a'; // Output is 97
								  return 0;
								}
							</pre>
							For Set 1, integer operations are performed for x - 'A' + 'a' and the resulting value, 65 - 65 + 97 = 97, is stored in the char variable v, which will then be converted to letter 'a'. Therefore, the output is a.
							<br/><br/>
							For Set 2, exactly the same things are performed except the resulting value, 65 - 65 + 97 = 97, is displayed on screen directly without putting back to a char variable before doing output. So the output is 97.
							<br/><br/>
							I hope the explanation is clear.
							<br/><br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
						
							<li><div style="font-weight: 500;">Date: 20 September 2016 (Tuesday)<br/><br/><span style="text-decoration:underline">Pre-increment and Post-increment Operator</span></div><br/>
							Referring to the following program, why the statement ++++++x; is legal while x++++++; is illegal?
							<br/><br/>
							<pre style="margin-left:-450px">
								#include <iostream>
								using namespace std;								
								int main() {
								  int x = 0;
								  cout << "pre = " << ++++++x; // legal
								  cout << "post = " << x++++++; // illegal
								  return 0;
								}
							</pre>														
							The reason of that could be explained as follows.<br/><br/>
							In C++, ++x (i.e. pre-increment) will return variable x after adding 1, but x++ (i.e. post-increment) will return the value of x after adding 1. With this concept, we interpret the statements as follows:
							<br/><br/>
							<ul>
								<li>++++++x is equivalent to ++(++(++x))
									<ul>
										<li>1st operation ++x, returns variable x</li>
										<li>2nd operation ++(x) could be done and returns variable x again</li>
										<li>3rd operation ++(x) could be done as well.
									</ul>
									<br/>
								</li>								
								<li>x++++++ is equivalent to ((x++)++)++
									<ul>
										<li>1st operation x++, returns the value of x</li>
										<li>2nd operation ++(value of x) could NOT be done as ++ operator cannot be applied on value</li>
									</ul>
								</li>
							</ul>
							<br/>
							I hope the explanation is clear.
							<br/><br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
							
							
							<li><div style="font-weight: 500;">Date: 20 September 2016 (Tuesday)<br/><br/><span style="text-decoration:underline">Scopes</span></div><br/>
							The following code defines two variable a and two variable b, but doesn't result with any error. Why?
							<br/><br/>
							<pre style="margin-left:-450px">
								void fun(double b) {								  
								  int a;
								  {
								    int b;
								    {
								       int a = 10;
								    }
								  }								  
								}
							</pre>							
							This is a very good question. In C++, local scopes are nested and searched inside out. Please refer to the following for explanation.
							<br/><br/>
							<pre style="margin-left:-450px">
								void fun(double b) {								  
								  int a; // outermost local scope
								  {
								    int b; // new scope can override function argument
								    {
								       int a = 10; // new scope can override outer local scope
								    }
								  }								  
								}
							</pre>		
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>							
							
							<li><div style="font-weight: 500;">Date: 20 September 2016 (Tuesday)<br/><br/><span style="text-decoration:underline">Function Overloading</span></div><br/>
							Can we define all of the followings in my program?<br/><br/>
							<pre style="margin-left:-450px">
								int absolute(int a) { return (a < 0) ? -a : a; }	
								int absolute(int& a) { return (a = (a < 0) ? -a : a; }
							</pre>							
							The answer is "yes / no". Suppose we call the function absolute as follows, then we won't get compilation error nor run-time error.
							<br/><br/>
							<pre style="margin-left:-400px">
							int main() {
							  int ans = absolute(5);
							  return 0;
							}
							</pre>
							However, if we try to call the function absolute by passing a variable to it, compilation error would occur as compiler got confused on which function to call.<br/><br/>
							<pre style="margin-left:-400px">
							int main() {
							  int value = 5;
							  int ans = absolute(value);
							  return 0;
							}
							</pre>							
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>	
							<li><div style="font-weight: 500;">Date: 22 February 2016 (Monday)<br/><br/><span style="text-decoration:underline">Initialization of variables</span></div><br/>
								This is a question regarding the initialization of variables in C++. In general, variables that are uninitialized contain garbage value, EXCEPT those that are global or with static duration.
								<br/><br/>
								Variables that are global / with static duration will be automatically initialized by C++. To illustrate the idea more clearly, let's see an example:<br/><br/>
								<pre style="margin-left:-450px">
									1. #include &lt;iostream&gt;
									2. using namespace std;
									3. 
									4. int globalVar;		// global
									5. static int staticGlobalVar;	// global and with static duration
									6.
									7. int main() {
									8.	int localVar;
									9.	static int staticLocalVar;	// with static duration
									10.
									11.	cout << "globalVar = " << globalVar << endl;
									12.	cout << "staticGlobalVar = " << staticGlobalVar << endl;
									13.	cout << "localVar = " << localVar << endl;
									14.	cout << "staticLocalVar = " << staticLocalVar << endl;
									15.	return 0;
									16.}
								</pre>
								<span style="text-decoration:underline">Output:</span><br/>
								<pre style="margin-left:-450px">
									globalVar = 0
									staticGlobalVar = 0
									localVar = 32767	// This is a garbage value
									staticLocalVar = 0
								</pre>
								In this example, we have declared 4 uninitialized variables, two global variables, one non-static and one static, two local variables, also one non-static and one static.
								<br/><br/>
								Among the 4 variables, only localVar (i.e. the one on line 8) will not be automatically initialized by C++ and therefore it contains garbage value. For the other three, they are also initialized to 0 by C++.
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 22 February 2016 (Monday)<br/><br/><span style="text-decoration:underline">Access of variables defined in different scopes but having the same name</span></div><br/>
								This is a question regarding the access of variables that are defined in different scopes but all having the same name.
								<br/><br/>
								Suppose we are given the following code.
								<br/><br/>
								<pre style="margin-left:-450px">
									1. int val;
									2. int main() {
									3.   int val;
									4.   val = 10;    // This val refers to the local variable defined in line 3
									5.   ::val = 20;  // This val refers to the global variable defined in line 1
									6.   {
									7.      int val;
									8.      val = 30; // This val refers to the local variable defined in line 7
									9.      // How? 
									10.  }
									11.  //...
									12.}
								</pre>
								The problem now is how to access the val defined in line 3 at line 9 (i.e. the line marked with "How?").
								<br/><br/>
								Answer:
								<br/><br/>
								There is no way to access the val defined in line 3 at line 9. It is because the val defined in line 3 has been hidden by the val defined in line 7. The only places that can access val defined in line 3 are:<br/><br/>
								<ul>
								  <li>Lines after 3 and before 6</li>
								  <li>Lines after 10 and before 12</li>
								</ul>
								<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>
					 <div id="tabs-2">
					 <h4 style="color:darkred; font-weight:bold">Pointers, references, memory allocation and de-allocation</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 1 March 2020 (Sunday)<br/><br/><span style="text-decoration:underline">Pointer to a 2D array</span></div><br/>
								Suppose we have a two-dimensional array arr as follows:<br/><br/>
<pre>int arr[][2] = { { 1, 2 }, { 2, 3 }, { 3, 4 } }; // A two-dimensional array of 3 rows, each with two columns
</pre>
<br/>
we can declare a pointer, p, that points at arr.
<br/><br/>
<pre>
// Syntax:
// &lt;type of the elements in 2D array&gt; (*&lt;pointer variable name&gt;)[<num of rows>][<num of cols>] = &amp;&lt;array name&gt;;
int (*p)[3][2] = &arr; // Note: & is a must.
</pre>
<br/>
With p, we can access each element in the array as follows:
<br/><br/>
<pre>
cout &lt;&lt; (*p)[0][0] &lt;&lt; endl; // Note: * is a must. This prints 1 on screen
cout &lt;&lt; (*p)[1][1] &lt;&lt; endl; // Note: * is a must. This prints 3 on screen
</pre>
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>								
							</li>							
							
							
							<li><div style="font-weight: 500;">Date: 1 March 2020 (Sunday)<br/><br/><span style="text-decoration:underline">Meaning and type of arr, &amp;arr and &amp;arr[0]</span></div>
								<br/>
								Suppose we define an array arr as:
								<br/>
								int arr[5];
								<br/><br/>
								The following explains the meaning of arr, &amp;arr and &amp;arr[0].<br/><br/>
								<ul>
									<li>&amp;arr[0]<br/>
									The address of the first element of arr. So, the type of &amp;arr[0] is <span style="color:red">int*</span>.
									</li>
									<li>arr<br/>
									<span style="color:red">A constant pointer</span> to the first element of array arr.
									</li>
									<li>&amp;arr<br/>
									<span style="color:red">A pointer to whole array of 5 ints.</span> So, &arr is the address of the array arr, which is also the same as the address of the first element. 
SINCE the starting address of an array represents the whole array.
									</li>
								</ul>
								<br/>
								In order to prove that &amp;arr[0], arr and &amp;arr are in different types (i.e. &amp;arr[0] is int*, arr is a constant pointer to the first element of array arr, and &amp;arr is a pointer to the whole array), we perform pointer arithmetic as follows:
								<br/><br/>
								<pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
  int arr[5];

  cout &lt;&lt; "&amp;arr[0]: " &lt;&lt; &amp;arr[0] &lt;&lt; endl;          // Print 0x7fffe5d7bd90
  cout &lt;&lt; "&amp;arr[0] + 1: " &lt;&lt; &amp;arr[0] + 1 &lt;&lt; endl;  // Print 0x7fffe5d7bd94

  // From the above, we see that &amp;arr[0] + 1 is an address 0x7fffe5d7bd90 + 4

  cout &lt;&lt; "arr: " &lt;&lt; arr &lt;&lt; endl;                  // Print 0x7fffe5d7bd90
  cout &lt;&lt; "arr + 1: " &lt;&lt; arr + 1 &lt;&lt; endl;          // Print 0x7fffe5d7bd94

  // From the above, we see that arr + 1 is an address 0x7fffe5d7bd90 + 4

  cout &lt;&lt; "&amp;arr: " &lt;&lt; &amp;arr &lt;&lt; endl;                // Print 0x7fffe5d7bd90
  cout &lt;&lt; "&amp;arr + 1: " &lt;&lt; &amp;arr + 1 &lt;&lt; endl;        // Print 0x7fffe5d7bda4

  // From the above, we see that &amp;arr + 1 is an address 0x7fffe5d7bd90 + 20
  // where 20 is the total number of bytes of the array arr.
  return 0;
}</pre>
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>								
							</li>
						
							<li><div style="font-weight: 500;">Date: 25 February 2020 (Tuesday)<br/><br/><span style="text-decoration:underline">Meaning of "const int* const*"</span></div><br/>
								The meaning of "const int* const*" is explained as follows:<br/><br/>
								<pre>
#include &lt;iostream&gt;
using namespace std;

int main() {
  /* Recall */
  int a = 10;
  int* const p = &amp;a;          // const here protects p, which cannot store other address value
  const int* q = &amp;a;          // const here protects a, which cannot be changed using q
  const int* const r = &amp;a;    // const near r protects r, which cannot store other address value
                              // const at the front protects a, which cannot be changed using r

  /* Now, we extend the idea to pointer variable s */
  int* s = &amp;a;
  int** const t = &amp;s;         // const here protects t, which cannot store other address value
  int* const * u = &amp;s;        // const here protects s, which cannot be changed using u
  const int* const * v = &amp;s;  // const near v protects s, which cannot be changed using v
                              // const at the front protects a, which cannot be changed using v

  /* Finally, we explain what "const int* const *" does for 2D array created using new */
  int** arr = new int*[3];
  for(int i=0; i<3; ++i)
    arr[i] = new int[4];

  // Note: arr stores the address of an int* variable
  int** const w = arr;        // const here protects w, which cannot store other address value
  int* const * x = arr;       // const here protects the array of pointers 
                              // (i.e. the one created using new int*[3]) pointed by arr,
                              // which cannot be changed using x
  const int* const * y = arr; // const near y protects the array of pointers 
                              // (i.e. the one created using new int*[3]) pointed by arr,
                              // which cannot be changed using y
                              // const at the front protects the arrays of ints
                              // (i.e. the ones created using new int[4]), which cannot be changed using y

  return 0;
}</pre>
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>								
							</li>
							<li><div style="font-weight: 500;">Date: 14 March 2016 (Monday)<br/><br/><span style="text-decoration:underline">Dynamically memory de-allocation</span></div><br/>
								You might have doubt on why C++ knows how much dynamic memory should be released using delete [] ptr.
								In fact, C++ actually does book keeping for the heap memory allocated to programs. So, when we do delete [] ptr, it releases appropriate amount of memory allocated earlier.
								<br/><br/>
								Another question you have in mind is what would happen if we put delete [] ptr, while ptr is pointing at a dynamic variable instead of a dynamic array. This is something platform dependent, i.e.
								the behaviour for using delete [] for a non-array pointer is undefined.
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>								
							</li>
							<li><div style="font-weight: 500;">Date: 21 February 2016 (Sunday)<br/><br/><span style="text-decoration:underline">Assigning an alias to dynamic variable</span></div><br/>
								The following shows how to assign an alias to dynamic variable.<br/><br/>
								<pre style="margin-left:-450px">
								#include &lt;iosteam&gt;
								using namespace std;
								int main() {
									int* p = new int;
										
									// Assign an alias "haha" to the dynamic variable pointed by p
									int& haha = *p;										
										
									// The dynamic varaible pointed by p got changed to 10
									haha = 10;
									cout << "*p = " << *p;
									delete p;
										
									// print the content of the de-allocated variable
									<span style="color:red">cout << "*p = " << *p << endl;</span>
										
									// assign a value to the de-allocated variable
									<span style="color:red">haha = 5;</span>
										
									// Directly assign an alias to dynamic variable
									int& hehe = *(new int);
										
									// Obtain the address of dynamic variable through hehe
									int* q = &hehe;
									
									// De-allocate the dynamic variable
									// (Same thing could be done by doing - delete &hehe)
									delete q;
																			
									return 0;
								}
								</pre>
								<br/>
								Please note that the two lines of code marked in red may cause troubles to our program.
								It is because variables that are de-allocated are no longer belong to our program. So, the behaviour of those is undetermined. Undetermined here means we are going to encounter one of the following:<br/><br/>
								<ul>
									<li>*p still gives you 10 and we are still able to change the value to 5 using reference variable haha (Because the dynamic variable is still not yet re-allocated to other program)</li>
									<li>The program will crash (Because the dynamic variable has been re-allocated to other program)</li>
								</ul>
								<br/>								
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 21 February 2016 (Sunday)<br/><br/><span style="text-decoration:underline">Questions on pointers and references</span></div><br/>
								The followings are some questions that I discussed with students during the review session yesterday. Please take a look and see if you know the answers. :-)
								<br/>
								<br/>
								For each of the following programs, state whether there is/are error(s). If there is/are error(s), explain why.
								For those lines using "cout", show what is displayed on screen (given that if they are legal).<br/><br/>
								<ol>
									<li>
										<pre style="margin-left:-600px">
											1.	#include &lt;iostream&gt;
											2.	using namespace std;
											3.
											4.	int main() {
											5.		int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8 };
											6.		int* p = &arr[5];
											7.		cout << "*p = " << *p << endl;
											8.		cout << "p[-3] = " << p[-3] << endl;
											9.		cout << "*(p+2) = " << *(p+2) << endl;
											10.		cout << "p[5] = " << p[5] << endl;
											11.		return 0;
											12.	}
										</pre>
									</li>
									<li>
										<pre style="margin-left:-600px">
											1.	#include &lt;iostream&gt;
											2.	using namespace std;
											3.	
											4.	int main() {
											5.		int* q = 0;
											6.		cout << "q is " << q << endl;
											7.		cout << "*q is " << *q << endl;
											8.		cout << "q[0] is " << q[0] << endl;
											9.		return 0;
											10.	}
										</pre>
									</li>
									<li>
										<pre style="margin-left:-600px">
											1.	#include &lt;iostream&gt;
											2.	using namespace std;
											3.
											4.	void func(int& haha) {
											5.		// ...
											6.	}
											7.
											8.	void funcwithconst(const int& haha) {
											9.		//...
											10.	}
											11.
											12.	int main() {
											13.		func(7);
											14.		funcwithconst(7);
											15.		return 0;
											16.	}
										</pre>
									</li>
								</ol>
								Answer:<br/><br/>
								<ol>
									<li>Yes, the program has error.<br/>
										On line 10, the statement accesses a location that is out of the legal range of array, which may cause runtime error.
										<br/><br/>
										<span style="text-decoration:underline">Output:</span><br/>
										Line 7: *p = 6<br/>
										Line 8: p[-3] = 3<br/>
										Line 9: *(p+2) = 8<br/>										
									</li>
									<br/>
									<li>Yes, the program has error.<br/>
										On line 7, the statement accesses the NULL location, which will cause runtime error.<br/>
										On line 8, same problem as on line 7.
										<br/><br/>
										<span style="text-decoration:underline">Output:</span><br/>
										Line 6: q is 0										
									</li>
									<br/>
									<li>Yes, the program has error.<br/>
										On line 13, the statement passes an integer literal (i.e. 7) to func by reference, which is illegal.<br/><br/>
										(Important: <span style="color:red">Line 14:</span>. Passing a literal to function with constant reference is legal.
										In this case, a temporary variable will be created at main to carry the literal and then being passed to the function.)
									</li>
									<br/>
								</ol>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 19 February 2016 (Friday)<br/><br/><span style="text-decoration:underline">const keyword on pointers</span></div><br/>
								We have discussed different uses of const keyword yesterday. Among all the different uses, the most tricky one is probably the ones on pointers.
								<br/><br/>
								In order to make it clear. Please refer to the following for more details:
								<br/><br/>
								<pre style="margin-left:-450px">
								  int a = 10;
								  
								  // Regular int pointer
								  int* p = &a;
								  
								  // Constant pointer variable
								  int* const q = &a;
								  
								  // A pointer to a constant
								  const int* r = &a;
								  
								  // This is <span style="color:red">equivalent to the last one</span>, i.e. the same as const int* r;
								  int const* s = &a;
								  
								  // A constant pointer to a constant
								  const int* const t = &a;
								  
								  // This is <span style="color:red">equivalent to the last one</span>, i.e. the same as const int* const t;
								  int const* const u = &a;
								</pre>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>							
								<hr/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>
					 <div id="tabs-3">
					 <h4 style="color:darkred; font-weight:bold">Classes and objects</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 8 March 2018 (Thursday)<br/><br/><span style="text-decoration:underline">Accessing Data Members</span></div><br/>
								Suppose we have name conflict between data members and local variables / parameters in member functions. How could we differentiate which is which?
								<br/><br/>
								There are two different ways to refer to data members in member functions, given that there is name conflict. First, we could use scope operator, and second we could use this keyword. Please refer to the following for an example.
								<br/><br/>
								<pre style="margin-left:-450px">
								#include &lt;iostream&gt;
								using namespace std;
								class A {
									private:
										int a = 10;
									public:
										void func1(int a = 20) {
											cout << "Data member a using scope operator: " << <span style="color:red">A::a</span> << endl;  // A::a refers to data member a
											cout << "Parameter a: " << a << endl; // a refers to parameter a
										}
										void func2(int a = 20) {
											cout << "Data member a using this keyword: " << <span style="color:red">this->a</span> << endl; // this->a refers to data member a
											cout << "Parameter a: " << a << endl; // a refers to parameter a
										}
								};
										
								int main() {
									A obj;
									obj.func1();
									obj.func2();
									return 0;
								}
								</pre>								
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 3 November 2016 (Thursday)<br/><br/><span style="text-decoration:underline">Returning const Pointer</span></div><br/>
								Given the following code:
								<br/><br/>
								<pre style="margin-left:-450px">
								class Person {
									public: 
										static Person* first;
										Person(string s); 
										Person(const Person& p);
										~Person( ); 
										string get name( ) const { return name; } 
										<span style="color:red">const</span> Person* get_next( ) const { return next; } 
									private: 
										string name; 
										Person* next; 
								};
								</pre>
								Why there is a const at the very beginning of get_next()?
								<br/><br/>
								It is because we want to avoid the change of the returned Person object. Please refer to the following for an example:
								<br/><br/>
								<pre style="margin-left:-450px">
								Person p("haha");
								
								<span style="color:red">// The following is invalid. If we allow this,</span>
								<span style="color:red">// then someone may use pointer q to indirectly access the</span>
								<span style="color:red">// object pointed by next, which is something we don’t want to.</span>								
								Person* q = p.get_next(); 
								</pre>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 2 March 2016 (Wednesday)<br/><br/><span style="text-decoration:underline">Constant member functions</span></div><br/>
								Constant member functions refer to those functions in class that are marked with a const keyword after the parenthesis.
								One thing that you may ask is "whether constant member functions could call non-constant member functions?".
								<br/>
								<br/>The answer is NO.<br/>
								<br/>
								For details, please refer to the table below:
								<br/><br/>
								<table>
									<tr>
										<th>Type of member functions</th>
										<th>Can call</th>
									</tr>
									<tr>
										<td>Constant member functions</td>
										<td>Constant member functions only</td>
									</tr>
									<tr>
										<td>Non-constant member functions</td>
										<td>Both constant member functions and non-constant member functions</td>
									</tr>
								</table>
								<br/>
								To further explain this, an example is given below.
								<br/><br/>
								<pre style="margin-left:-500px">
									class Person {
										private:
											string name;
											int age;
											char gender;
										public:
											Person() {
												name = "Hello Kitty";
												age = 5;
												gender = 'F';
											}
											void setName(string n) {
												name = n;
											}
											string getName() const {
												return name;
											}
											int getAge() const {
												return age;
											}
											char getGender() const {
												return gender;
											}
											void print() const {
												<span style="color:red">// Error: Since constant member function cannot
												// call non-constant member function</span>
												setName("Desmond");
												
												<span style="color:red">// All the followings are okay, since constant
												// member function can call constant member functions</span>
												cout << "Name: " << getName();
												cout << "Age: " << getAge();
												cout << "Gender: " << getGender();
											}
											void doSomething() { // Non-constant member functions
												<span style="color:red">// Calling non-constant member function is okay</span>
												setName("Desmond");
												
												<span style="color:red">// Calling constant member function is okay</span>
												cout << "Name: " << getName() << endl;
												cout << "Have fun!" << endl;
											}
									};
								</pre>								
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 19 February 2016 (Friday)<br/><br/><span style="text-decoration:underline">Member access of calling object / caller and object parameter</span></div><br/>
								The following shows the example that I used for explaining the concept of member access:
								<br/><br/>
								<pre style="margin-left:-450px">
								  #include &lt;string&gt;
								  using namespace std;
								  
								  class Person {
								    private:
									  string name;
									  int age;
									public:
									  void func(Person& p) {
										// p.name refers to the name variable in p2
										p.name = "desmond";
										// name refers to the one in the calling object p1
										name = "brian";
									  }
								  };
								  
								  int main() {
									Person p1;
									Person p2;
									p1.func(p2);
									return 0;
								  }
								</pre>								
								By putting const keywords to the example, we restrict the change of different members.								
								<br/><br/>
								<pre style="margin-left:-450px">
								  #include &lt;string&gt;
								  using namespace std;
								  
								  class Person {
								    private:
									  string name;
									  int age;
									public:
									  void func(<span style="color:red">const</span> Person& p) <span style="color:red">const</span> {
										// p.name refers to the name variable in p2
										// <span style="color:red">(ERROR - because of the const on the left)</span>
										p.name = "desmond";										
										// name refers to the one in the calling object p1
										// <span style="color:red">(ERROR - because of the const in the parameter list)</span>
										name = "brian";
									  }
								  };
								  
								  int main() {
									Person p1;
									Person p2;
									p1.func(p2);
									return 0;
								  }
								</pre>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 18 February 2016 (Thursday)<br/><br/><span style="text-decoration:underline">Clarification on const / non-const object to function with parameter of const / non-const object</span></div><br/>
								I would like to clarify one of the questions that you asked during the lecture this afternoon. During the lecture, one of you asked whether we are able to pass const / non-const object to function with parameter of const / non-const object. The answer is "YES".<br/><br/>
								In other words, we could do the following:
								<ul>
									<li>non-const object -> function with parameter of const object (OK)</li>
									<li>non-const object -> function with parameter of non-const object (OK)</li>
									<li>const object -> function with parameter of const object (OK)</li>
									<li>const object -> function with parameter of non-const object (OK)</li>
								</ul>
								<br/>
								For details, please refer to the following code.
								<br/><br/>
								<pre style="margin-left:-500px">
									#include &lt;iostream&gt;
									using namespace std;
									
									class Person {
									  private:
										int age;
										char gender;
									  public:
										Person() { age = 0; gender = 'M'; }
									};
									
									void constO(const Person p) { }
									void nonConstO(Person p) { }
									
									int main() {
									  Person q;
									  const Person r;
										
									  constO(q);    // non-const object to function with parameter of const object (OK)
									  nonConstO(q); // non-const object to function with parameter of non-const object (OK)
									  constO(r);    // const object to function with parameter of const object (OK)
									  nonConstO(r); // const object to function with parameter of non-const object (OK)
									  return 0;
									}
								</pre>								
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>							
								<hr/>
								<br/>
							</li>
						</ul>
					 </p>	
					 </div>					 
					 <div id="tabs-4">
					 <h4 style="color:darkred; font-weight:bold">Separate compilation and makefile</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 12 February 2016 (Friday)<br/><br/><span style="text-decoration:underline">g++ compiler options</span></div><br/>
								As we have started some discussion on separate compilation yesterday, I think it's time for me to go through some g++ options with you.
								I hope you will find the following useful.
								<br/><br/>
								<table>
									<tr>
										<th style="width:25%">Option</th>
										<th style="width:75%">Description</th>
									</tr>
									<tr>
										<td>--version</td>
										<td>Display the version of g++</td>
									</tr>
									<tr>
										<td>--help</td>
										<td>Get the help manual of g++</td>
									</tr>
									<tr>
										<td>-g</td>
										<td>Put debugging information for gdb (GNU debugger) into the object or executable file</td>
									</tr>
									<tr>
										<td>-Wall</td>
										<td>Print all warning messages</td>
									</tr>
									<tr>
										<td>-O or -O2</td>
										<td>Turn on optimization<br/>(Note: The letter is captial O)</td>
									</tr>
									<tr>
										<td>-o &lt;name of file&gt;</td>
										<td>Specify the name of the output file</td>
									</tr>
									<tr>
										<td>-c</td>
										<td>Compile the source file into an object file (.o).<br/>(Note: By default, the object file has the same name as the source file.)</td>
									</tr>
									<tr>
										<td>-I&lt;include path&gt;</td>
										<td>Specify an include directory</td>
									</tr>
									<tr>
										<td>-L&lt;library path&gt;</td>
										<td>Specify a lib directory</td>
									</tr>
									<tr>
										<td>-l&lt;library&gt;</td>
										<td>Link with library lib&lt;library&gt;.a</td>
									</tr>
								</table>
								<br/>
								Examples:<br/><br/>
								Suppose we have three programs that are independent to each other.
								<ol style="line-height:150%">
									<li>myprogram.cpp</li>
									<li>file1.cpp<br/>
										file2.cpp<br/>
										file3.cpp<br/>
										main.cpp</li>										
									</li>
									<li>otherprogram.cpp<br/>
										libhaha.a (Note: Assume libhaha.a is in the directory /lib)<br/>
										(the file libhaha.a could be generated from haha.o using the command: ar crf lib/libhaha.a haha.o)
									</li>									
								</ol>
								<br/>
								Commands:
								<ul style="line-height:150%">
									<li>g++ --version<br/>It displays the version of g++ compiler</li>
									<li>g++ --help<br/>It gets the help manual of g++</li>
									<li>g++ myprogram.cpp<br/>It creates an executable program "a.out" for the first program.<br/>(Note: a.out is the default name if the executable file name is not specified)</li>
									<li>g++ -o firstprogram myprogram.cpp<br/>It creates an execuatable program "firstprogram"</li>
									<li>g++ -o firstprogram -g myprogram.cpp<br/>It creates an executable program "firstprogram" contains information that enables it to be debugged with the gdb debugger</li>
									<li>g++ -o firstprogram -Wall myprogram.cpp<br/>It creates an executable program "firstprogram" and displays all the warnings if any</li>
									<li>g++ -o firstprogram -O myprogram.cpp<br/>It creates an optimized executable program "firstprogram" from myprogram.cpp</li>
									<li>g++ -c myprogram.cpp<br/>It creates an object file "myprogram.o" from myprogram.cpp</li>
									<li>g++ -o firstprogram.o -c myprogram.cpp<br/>It creates an object file "firstprogram.o" from myprogram.cpp</li>
									<li>g++ -c file1.cpp file2.cpp file3.cpp main.cpp<br/>It creates object files "file1.o", "file2.o", "file3.o", "main.o" for the second program</li>
									<li>g++ -o secondprogram.exe file1.cpp file2.cpp file3.cpp main.cpp<br/>It creates an executable program "secondprogram.exe" by (1) compilating file1.cpp, file2.cpp, file3.cpp and main.cpp, and (2) linking them together.<br/>(Note: No object file of individual file will be created.)</li>
									<li>g++ -o secondprogram.exe file1.o file2.o file3.o main.o<br/>It creates an executable program "secondprogram.exe" by linking file1.o, file2.o, file3.o, and main.o together</li>
									<li>g++ -o thirdprogram.exe otherprogram.cpp -L/lib -lhaha<br/>It creates an executable program "thirdprogram.exe" by (1) compiling otherprogram.cpp, and (2) linking it with /lib/libhaha.a together<br/>(Note: The substring "lib" of the file "libhaha.a" is not required for the -l option.)</li>
								</ul>
								<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>							
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 5 February 2016 (Friday)<br/><br/><span style="text-decoration:underline">Difference between .o and .a files</span></div><br/>
								I would like to explain the difference between .o and .a files as mentioned on page 18 of the second set of lecture notes here.<br/><br/>
								.o files are object files produced by compiler. It consists of the intermediary form of machine code converted from source code written in high-level language.<br/><br/>
								<ul>
								  <li>Object code files on Windows have file extension .obj</li> 
								</ul>
								<br/>
								.a files are archive files that contain a collection of object files.
								<br/><br/>								
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>							
								<hr/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>
					 <div id="tabs-5">
					 <h4 style="color:darkred; font-weight:bold">Constructors, initialization and destructor</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 3 November 2016 (Thursday)<br/><br/><span style="text-decoration:underline">explicit keyword at Copy Constructor</span></div><br/>
							What happen if we add explicit keyword at copy constructor?
							<br/><br/>
							If we put explicit keyword at copy constructor, then the copy constructor cannot be called implicitly, e.g.,
							<br/><br/>
							<pre class="prettyprint">
class A {
		int a;
	public:
		A(int a = 10) { this->a = a; }
		explicit A(const A& a) {}
};
	
int main() {
	A obj = A(10); 									
	<span style="color:red">
	// The above line will cause compilation error, 
	// since it calls copy constructor implicitly.
	</span>									
	return 0;
}
							</pre>
							<br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 2 October 2016 (Sunday)<br/><br/><span style="text-decoration:underline">Copy Constructor without &</span></div><br/>
							Can we omit operator & when defining copy constructor?
							<br/><br/>
							If operator & is omitted, the constructor will cause compilation error. Please refer to the following for an example:
							<br/><br/>
							<pre class="prettyprint">
class A {
	public:
		A() {} <span style="color:red">// default constructor</span>
		A(const A a) { } <span style="color:red">// "copy constructor"</span>
};
	
int main() {
	A obj1;
	<span style="color:red">
	// The line A obj2(obj1) causes compilation error, 
	// since when obj1 is passed to A(const A a), we’ve got
	// const A a = obj1;
	//
	// - This is weird! We called the "copy constructor"
	//   but after passing obj1 to it, const A a = obj1; 
	//   needs to construct an object "a" using 
	//   "copy constructor" as well.
	// - This causes infinite recursion because
	//   "to make a copy, we need to make a copy"
	// - This is what we called deadlock and is an
	//   undetermined behavior.
	</span>
	A obj2(obj1);
	return 0;
}
							</pre>
							<br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 2 October 2016 (Sunday)<br/><br/><span style="text-decoration:underline">Copy Constructor (Function Body)</span></div><br/>
								What if we use the formal copy constructor function declaration, i.e. A(const A& a) for class A, but the function body is something else? For example, we only copy some of the data members but not all. Can we still call it a "copy constructor?"
								<br/><br/>
								In terms of syntax, it is still a copy constructor, but it is not in terms of semantics. In Object-Oriented Programming, we do care about both syntax and semantics. So, programmers should always define formal copy constructor (i.e., with const and &) and make use of the passed object for initialization of the current data members.								
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
						
							<li><div style="font-weight: 500;">Date: 14 March 2016 (Monday)<br/><br/><span style="text-decoration:underline">Initialization using initializer</span></div><br/>
								As mentioned, we can initialize an object using initializer (i.e. { }) when all the data members are public. For instance:
								<br/><br/>
								<pre class="prettyprint">
class A {
	public:
		int a;
		int b;
};

int main() {
	<span style="color:red">// data member a of obj is assigned as 1</span>
	<span style="color:red">// data member b of obj is assigned as 2</span>
	A obj = { 1, 2 };
	return 0;
}
								</pre>
								But you might notice that initializer doesn't work if we have constructor(s) in class, even all the data members are public.
								<br/><br/>
								The following gives an example:
								<br/><br/>
								<pre class="prettyprint">
class A {
	public:
		int a;
		int b;
		A() { }
};

int main() {
	<span style="color:red">// The following line of code is illegal</span>
	A obj = { 1, 2 };
	return 0;
}
								</pre>
								<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 2 March 2016 (Wednesday)<br/><br/><span style="text-decoration:underline">Object destruction</span></div><br/>
								As mentioned in class, objects will be destructed in one of the following situations:
								<br/>
								<br/>
								<ul>
									<li>Go out of scope</li>
									<li>Being de-allocated using delete operator</li>
								</ul>
								<br/>
								For the first case, i.e. go out of scope, some of you might have doubt on what would happen if we return from function not around the end of function, i.e.
								<br/><br/>
								<pre class="prettyprint">
#include &lt;iostream&gt;
using namespace std;
class A {
	public:
		~A() { cout << "Destructor is called" << endl; }
};

void func() {
	A obj1;
	cout << "Before return" << endl;
	return;		<span style="color:red">// Leaving the function func</span>
	A obj2;		<span style="color:red">// This statement is not executed</span>
}

int main() {
	cout << "Before calling func" << endl;
	func();
	cout << "After calling func" << endl;
	return 0;
}
								</pre>
								The answer is obj1 will be destroyed when we reach the line "return;". To show this is the case, let's see the output of the program:
								<br/><br/>
								Output:
								<pre style="margin-left:-450px">
									Before calling func
									Before return
									Destructor
									After calling func
								</pre>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 27 February 2016 (Saturday)<br/><br/><span style="text-decoration:underline">Constant pointer variable</span></div><br/>
								As mentioned during the additional class, constant variables must be initialized using member initialization list.
								<br/><br/>
								Then, you might want to ask "how to initialize a constant pointer variable (e.g. int* const p) with the address of
								a dynamic array?". For this, we could do:
								<br/><br/>
								<pre class="prettyprint">
#include &lt;string&gt;
using namespace std;

class Student {
	private:
		string name;
		int* const arr; // constant pointer variable arr
	public:
		Student() : name("Peter"), arr(new int[20]) {}
};
								</pre>
								<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 27 February 2016 (Saturday)<br/><br/><span style="text-decoration:underline">Member initialization list</span></div><br/>
								During the additional class, we have discussed the use of member initialization list.
								One question you might have in mind is "where should I put the member initialization list? .h or .cpp or both"?<br/><br/>
								The answer is: we should put it <span style="color:red">either in .h or .cpp</span>. In other words, we could not put member initialization list in both files.
								In addition, member initialization list <span style="color:red">must be defned at the same place as the constructor's body</span>.
								<br/><br/>
								Please refer to the following for an example:
								<pre class="prettyprint">									
// Person.h
#include &lt;string&gt;
using namespace std;

class Person {
	private:
		string name;
		int age;
		char gender;
	public:
		// The member initialization list needs to be placed at the same place as {}
		Person(string n, int a, char g) : name(n), age(a), gender(g) {}
		void speak();
};

// Person.cpp
#include &lt;iostream&gt
#include "Person.h"
using namespace std;

void Person::speak() {
	cout << "Desmond is a good guy!" << endl;
}

//====
// OR
//====

// Person.h
#include &lt;string&gt;
using namespace std;	

class Person {
	private:
		string name;
		int age;
		char gender;
	public:											
		Person(string n, int a, char g);
		void speak();
};

// Person.cpp
#include &lt;iostream&gt
#include "Person.h"
using namespace std;

// The member initialization list needs to be placed at the same place as {}
Person(string n, int a, char g): name(n), age(a), gender(g) {}

void Person::speak() {
	cout << "Desmond is a good guy!" << endl;
}
								</pre>
								<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>						
							<li><div style="font-weight: 500;">Date: 26 February 2016 (Friday)<br/><br/><span style="text-decoration:underline">More about copy constructor</span></div><br/>
								The following shows interesting cases about copy constructor
								<br/><br/>
								Case 1:<br/><br/>
								<pre class="prettyprint">
// Person.cpp
1. #include &lt;iostream&gt
2. using namespaces td;
3.
4. class Person {
5.	public:
6.		Person() { cout << "Person()" << endl; }
7.		Person(const Person p) { cout << "Person(const Person p)" << endl; }
8.		Person(Person p) { cout << "Person(Person p)" << endl; }
9. };
10.
11. int main() {
12.		const Person r;
13.		Person s(r);
14.		return 0;
15. }
								</pre>
								This program has compilation errors.<br/><br/>
								Error message:<br/><br/>
								<pre style="margin-left:-500px">
									Person.cpp:7: error: invalid constructor; you probably meant Person (const Person&)?
									Person.cpp:7: error: invalid member function declaration
									Person.cpp:8: error: invalid constructor; you probably meant Person (const Person&)?
									Person.cpp:8: error: invalid member function declaration
								</pre>
								<br/>
								Case 2:<br/><br/>
								<pre class="prettyprint">
// Person.cpp
1. #include &lt;iostream&gt
2. using namespaces td;
3.
4. class Person {
5.	public:
6.		Person() { cout << "Person()" << endl; }
7.		Person(Person& p) { cout << "Person(Person& p)" << endl; }
8. };
9.									
10. int main() {
11.		const Person r;
12.		Person s(r);
13.		return 0;
14. }
								</pre>
								This program also has compilation errors.<br/><br/>
								Error message:<br/><br/>
								<pre style="margin-left:-500px">
									Person.cpp: In function int main()?
									Person.cpp:12: error: no matching function for call to Person::Person(const Person&)?
									Person.cpp:7: note: candidates are: Person::Person(Person&)
									Person.cpp:6: note:                 Person::Person()
								</pre>
								<span style="color:red">From this, we are able to see that the default copy constructor is not given by C++.</span>
								<br/>
								<br/>
								Case 3:<br/><br/>
								<pre class="prettyprint">
// Person.cpp
1. #include &lt;iostream&gt
2. using namespaces td;
3.
4. class Person {
5.	public:
6.		Person() { cout << "Person()" << endl; }
7.		Person(const Person& p) { cout << "Person(Person& p)" << endl; }
8.		Person(Person& p) { cout << "Person(Person& p)" << endl; }
9. };
10.									
11. int main() {
12.		const Person r;
13.		Person s(r);
14.		return 0;
15. }
								</pre>
								This program is correct and the output is:
								<pre style="margin-left:-500px">
									Person(const Person& p)
								</pre>
								<span style="color:red">From the above, we can see that we could define two constructors at the same time: (1) copy constructor and
								(2) a constructor looks like copy constructor but without const.</span>
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>							
							<li><div style="font-weight: 500;">Date: 26 February 2016 (Friday)<br/><br/><span style="text-decoration:underline">Copy constructor</span></div><br/>
								Recall, a copy constructor is a constructor that accepts an object of the same type by reference. The following shows an example:<br/><br/>
								<pre class="prettyprint">
class Person {
	private:
		string name;
		int age;
		char gender;
	public:
		// Copy constructor of Person type
		Person(const Person& p) {
			name = p.name;
			age = p.age;
			gender = p.gender;
		}
};
								</pre>
								Now, we need to discuss when copy constructor will be called. 
								Suppose we are talking about the copy constructor of class A, the following summarizes the situations
								where the copy constructor of class A is called.
								<br/><br/>
								<ol>
									<li>When an object of type A is constructed and initialized by an object of type A.</li>
									<li>When an object of type A is passed to a function by value.</li>
									<li>When a function returns an object of type A.</li>									
								</ol>
								<br/>
								The following demonstrates all these cases.
								<br/><br/>
								<pre class="prettyprint">
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Person {
	private:
		string name;
		int age;
		char gender;
	public:
		Person() {
			cout << "Default constructor" << endl;
		}
		Person(const Person& p) {
			cout << "Copy constructor" << endl;
		}
};

Person func(Person q) {
	return q;
}

int main() {
	// The following constructs a Person object and
	// initializes the object using default constructor
	Person desmond;
	
	// <span style="color:red">[ Case 1 ]</span>
	// The following constructs a Person object and
	// initializes the object by another object of the
	// same type. Therefore, copy constructor is called
	Person brian(desmond);
	
	// The following statement calls copy constructor twice										
	Person retObj = func(desmond);
	
	// Explanation:
	// ============
	// 1. func(desmond) <span style="color:red">[ Case 2 ]</span>
	//    When an object of Person type (i.e. desmond) is
	//    passed to func, then something likes
	//      Person q = desmond;
	//    is done. Therefore copy constructor is called.
	// 2. Person retObj = &lt; the returned Person type object &gt; <span style="color:red">[ Case 3 ]</span>
	//    Copy constructor is called also.
	
	return 0;
}
								</pre>
								Output:
								<pre style="margin-left:-500px">
									Default constructor
									Copy constructor
									Copy constructor
									Copy constructor
								</pre>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 24 February 2016 (Wednesday)<br/><br/><span style="text-decoration:underline">private constructor</span></div><br/>
								If constructors are private, only member functions within the same class can access them.
								The following code demonstrates the idea:
								<br/><br/>
								<pre class="prettyprint">
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Person {
	private:
		string name;
		int age;
		char gender;
		<span style="color:red">// private constructor</span>
		Person(string n, int a, char g) {
			cout << "private constructor" << endl;
		}
	public:
		Person() {
			cout << "public default constructor" << endl;
		}
		void func() {
			// The one below is okay. Since this function "func()"
			// is in the same class as the Person constructor that
			// accepts three parameter. So even the constructor is
			// private, we are able to access it.
			Person objInMemFunc("Peter", 17, 'M');
		}
};

int main() {
	// The following is okay, since default constructor is public
	Person myFirstObj;
	// The following is okay, since func is public
	myFirstObj.func();
	<span style="color:red">// The following is invalid, since the constructor that</span>
	<span style="color:red">// accepts three parameters is private</span>
	Person objectInMain("Desmond", 18, 'M');
	return 0;
}
								</pre>								
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 23 February 2016 (Tuesday)<br/><br/><span style="text-decoration:underline">explicit keyword</span></div><br/>
								Recall, explicit keyword in C++ is used to prevent implicit conversion using constructor.
								<br/><br/>
								For example:
								<br/><br/>
								<pre class="prettyprint">
class Person {
	private:
		int age;
		char gender;
	public:
		Person(int a) {
			age = a;
			gender = 'M';
		}
};

void mysteryFunc(Person p) {
	// ...
}

int main() {
	mysteryFunc(10);
	return 0;
}
								</pre>
								The mysteryFunc is invoked by passing the literal 10 to it. At the first glance, this is something illegal as
								an int is being passed to the function where it supposes to accept Person type object only. But the truth is, it is legal. Because
								C++ does something for us undernealth (see below).
								<br/><br/>
								When mysteryFunc(10) is executed, 10 is passed to the conversion constructor of Person, i.e. Person(int a). 
								After that, a temporary Person type object is constructed and being passed to mysteryFunc as parameter.
								<br/><br/>
								In other words, the calling of mysteryFunc with int value 10 is being made legal via the INDIRECT / IMPLICIT
								call of the Person conversion constructor.
								<br/><br/>
								Now, say we want to prevent the implicit call of conversion constructor happen. Then, what we have to do is simply
								add an explicit keyword before the constructor, i.e.<br/><br/>
								<pre class="prettyprint">
class Person {
	private:
		int age;
		char gender;
	public:
		<span style="color:red">explicit</span> Person(int a) {
			age = a;
			gender = 'M';
		}
};

void mysteryFunc(Person p) {
	// ...
}

int main() {
	mysteryFunc(10);
	return 0;
}
								</pre>
								With this, the line mysteryFunc(10) will become invalid, i.e. with compilation error.
								<br/><br/>
								Another question regarding explicit keyword is:
								Do we need to put explicit keyword in both .h and .cpp file if we want to separate the class implementation in two files.
								<span style="color:red">The answer is NO!</span> i.e., we only have to put the explicit keyword in .h, not .cpp.
								The following shows an example:
								<br/><br/>
								<pre class="prettyprint">
// Person.h
#ifndef PERSON_H
#define PERSON_H

class Person {
	private:
		int age;
		char gender;
	public:
		<span style="color:red">explicit</span> Person(int a);
};

#endif

// Person.cpp
#include &lt;Person.h&gt;
Person::Person(int a) { // no explicit keyword is needed here
	age = a;
	gender = 'M';
}																		

// main.cpp
#include &lt;Person.h&gt;
void mysteryFunc(Person p) {
	// ...
}

int main() {
	mysteryFunc(10);
	return 0;
}
								</pre>
								I hope the idea is clear.<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>
					 <div id="tabs-6">					 
					 <h4 style="color:darkred; font-weight:bold">Inheritance</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 19 March 2018 (Monday)<br/><br/><span style="text-decoration:underline">Access of private member function(s) via dynamic binding</span></div><br/>
								Suppose we have two classes, base class A, and derived class B that inherits A. Both have a member function func(). The one in A is defined under public, and the one in B is defined under private.
								<br/><br/>
								The following gives the details:
								<br/><br/>
								<pre style="margin-left: -500px">
									#include &lt;iostream&gt;
									using namespace std;
									class A {
										public:
											virtual void func() {
												cout << "func in A" << endl;
											}
									};
									
									class B : public A {
										private:
											void func() {
												cout << "func in B" << endl;
											}
									};
									
									int main() {
										B bObj;
										bObj.func(); // Error. Since func() in B is private
										A& aRef = bObj; // Liscov substitution principle
										aRef.func(); // We can call func() in B via dynamic binding, even it is private
									}
								</pre>
								Observations:
								<br/><br/>
								If we use type B object bObj to call the member function func(), error occurs as func() in B is private. But we could access func() in B via dynamic binding, i.e.
								<ul>
									<li>Use type A reference variable aRef to refer to bObj.</li>
									<li>Then use aRef to call func() and the following occurs:
									<ul>
										<li>Type of aRef is A, so we should first reach func() in A</li>
										<li>virtual keyword is found at func() in A and so we need to check what type of object aRef is referring to. <br/>
										aRef is referring to B type object.</li>
										<li>So, func() in B is called. // Note it is a private member function.</li>
									</ul>
									</li>
								</ul>
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 15 March 2018 (Thursday)<br/><br/><span style="text-decoration:underline">About virtual destructor</span></div><br/>
								Suppose we have two classes, base class A, and derived class B that inherits A.
								<br/><br/>
								<pre style="margin-left: -500px">
									class A {
										public:
											A() { }
											~A() { }
									};
									
									class B : public A {
											int* p;
										public:
											B() { p = new int; }
											~B() { delete p; }
									};
									
									int main() {
										A* aPtr = new B;
										delete aPtr;
										return 0;
									}
								</pre>
								When we compile and execute the program, the following occurs.<br/><br/>
								<ol>
									<li>new B; // Create an object of type B and call the default constructor of B</li>
									<li>: A() is added by g++ to the default constructor of B, and so the default constructor of A is called</li>
									<li>Create the data member variable p</li>
									<li>Execute new int and the address of the unnamed variable created using “new int” is stored in p</li>
									<li>aPtr stores the address of unnamed object of type B</li>
									<li>delete aPtr;
										<ul>
											<li>As the type of aPtr is A, we first reach the destructor of A</li>
											<li>As no virtual keyword is found at the destructor of A. So, ~A() is called.</li>
										</ul>
									</li>
								</ol>
								<br/>
								The problem of the above is that the memory obtained using "new int" in the constructor of B (i.e. in step 4) is not de-allocated. It is because the destructor of A is called instead of the destructor of B, and this results memory leak.
								<br/><br/>
								To fix the problem, virtual keyword should be added to the destructor of A, which is as follows:
								<br/><br/>
								<pre style="margin-left: -500px">
									class A {
										public:
											A() { }
											<span style="color:red">virtual</span> ~A() { }
									};
									
									class B : public A {
											int* p;
										public:
											B() { p = new int; }
											~B() { delete p; }
									};
									
									int main() {
										A* aPtr = new B;
										delete aPtr;
										return 0;
									}
								</pre>
								Now, the followings would be done instead.
								<br/><br/>
								<ol>
									<li>new B; // Create an object of type B and call default constructor of B <span style="color:blue">(SAME AS ABOVE)</span></li>
									<li>: A() is added by g++ to the default constructor of B, so default constructor of A is called <span style="color:blue">(SAME AS ABOVE)</span></li>
									<li>Create the data member variable p <span style="color:blue">(SAME AS ABOVE)</span></li>
									<li>Execute new int and the address of the unnamed int variable is stored in p <span style="color:blue">(SAME AS ABOVE)</span></li>
									<li>aPtr stores the address of unnamed object of type B <span style="color:blue">(SAME AS ABOVE)</span></li>
									<li>delete aPtr;
									<ul>
										<li>As the type of aPtr is A, we first reach the destructor of A</li>
										<li>There is a virtual keyword at the destructor of A, and so we need to check what type of object is pointed by aPtr. It’s a type B object. So we should call the destructor in B.</li>
										<li>delete p; is executed to de-allocate the unnamed int that we created earlier.</li>
									</ul>
									</li>
								</ol>
								<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							
							<li><div style="font-weight: 500;">Date: 8 March 2018 (Thursday)<br/><br/><span style="text-decoration:underline">Initialization of Data Members inherited from Base Class</span></div><br/>
								With inheritance, all the data members and member functions (except constructors, destructor, and assignment operator function) of a base class will be inherited to a derived class, and the obtained data members should be initialized. How? Let's take a look at the following example:
								<br/><br/>
								<pre style="margin-left: -500px">
									class Base {
										private:
											int b;
										public:
											Base(int b) : b(b) {}
									};
									class Derived : public Base {
										private:
											int d;
										public:
											// Data member b inherited from Base
											// is initialized using MIL, i.e. : Base(b)
											Derived(int b, int d) : Base(b), d(d) {}
									};
								</pre>
								Referring to the example above, you can see that initialization of data members obtained from the base class (b in this example) should always be done by the Base class constructor triggered by the MIL of the derived class. Now, you may ask what would happen if we don't put ": Base(b)" in the Derived constructor, i.e.,
								<br/><br/>
								<pre style="margin-left: -500px">
									class Derived : public Base {
										private:
											int d;
										public:
											// No ": Base(b)" in the MIL
											Derived(int b, int d) : d(d) {}
									};
								</pre>
								In this case, C++ compiler will automatically add ": B()" to your constructor, which your code would become:
								<br/><br/>
								<pre style="margin-left: -500px">
									class Derived : public Base {
										private:
											int d;
										public:
											// Base() is added by the C++ compiler
											<span style="color:red">// This causes compilation error as there is no default constructor in Base class.</span>
											Derived(int b, int d) : <span style="color:red">Base()</span>, d(d) {}
									};
								</pre>
								In other words, default constructor of the Base class will be called for initializing the inherited data member b. So, please bear in mind that "Data members obtained from a base class SHOULD always be initialized by a constructor in the base class, and this is triggered by MIL in the derived class".
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 16 March 2017 (Thursday)<br/><br/><span style="text-decoration:underline">virtual destructor</span></div><br/>
								The following is an example demostrating the use of virtual destructor.
								<br/><br/>
								<pre style="margin-left: -500px">
									#include &lt;iostream&gt;
									using namespace std;
									
									class Base {
										private:
											int* p;
										public:
											Base() {
												p = new int[5];
												cout << "Base's constructor" << endl;
											}
											~Base() {
												delete [] p;
												cout << "Base's destructor" << endl;
											}
									};
									
									class Derived : public Base {
										private:
											int* q;
										public:
											Derived() {
												q = new int[10];
												cout << "Derived's constructor" << endl;
											}
											~Derived() {
												delete [] q;
												cout << "Derived's destructor" << endl;
											}
									};
										
									int main() {
										Base* b = new Derived;
										delete b;
										return 0;
									}
									
									Output:
									Base's constructor
									Derived's constructor
									Base's destructor
								</pre>
								There is no virtual keyword at the destructor of the base class. So, the program only invoke the Base' destructor.
								<br/><br/>
								The following shows the same example but virtual keyword is available at the destructor of the base class.
								<br/><br/>
								<pre style="margin-left: -500px">
									#include &lt;iostream&gt;
									using namespace std;
									
									class Base {
										private:
											int* p;
										public:
											Base() {
												p = new int[5];
												cout << "Base's constructor" << endl;
											}
											<span style="color:red">virtual</span> ~Base() {
												delete [] p;
												cout << "Base's destructor" << endl;
											}
									};
									
									class Derived : public Base {
										private:
											int* q;
										public:
											Derived() {
												q = new int[10];
												cout << "Derived's constructor" << endl;
											}
											~Derived() {
												delete [] q;
												cout << "Derived's destructor" << endl;
											}
									};
										
									int main() {
										Base* b = new Derived;
										delete b;
										return 0;
									}
									
									Output:
									Base's constructor
									Derived's constructor
									Derived's destructor
									Base's destructor
								</pre>
								Now, the program will invoke Derived's destructor and also Base's destructor.
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 14 March 2017 (Tuesday)<br/><br/><span style="text-decoration:underline">"has-a" relationship via composition and private inheritance</span></div><br/>
								We have shown that "has-a" relationship can be achieved using either composition or private inheritance. The following shows the main similarity and difference between the two.								
								<br/><br/>
								<span style="text-decoration:underline">Similarity:</span>
								<br/><br/>
								<pre style="margin-left: -500px">
									class A {
									};
									
									class B {
										private:
											// "has-a" relationship achieved using composition
											A obj;										
									};
									
									// "has-a" relationship achieved using private inheritance
									class C : private A {										
									};
									
									// "is-a" relationship
									class D : public A {
									};
									
									int main() {
										B objB;
										C objC;
										D objD;
										A* aPtr1 = static_cast&lt;A*&gt;(&amp;objB); <span style="color:red">// Illegal</span>
										A* aPtr2 = static_cast&lt;A*&gt;(&amp;objC); <span style="color:red">// Illegal</span>
										A* aPtr3 = static_cast&lt;A*&gt;(&amp;objD); <span style="color:red">// Legal</span>
										return 0;
									}
								</pre>
								We are unable to cast type B (composition) and type C (private inheritance) pointer to type A.
								<br/>
								<br/>								
								<span style="text-decoration:underline">Difference:</span>
								<br/><br/>
								<pre style="margin-left: -500px">
									#include &lt;iostream&gt;
									using namespace std;
									
									class A {
										private:
											int a;
										protected:
											int b;
										public:
											int c;
									};
									
									class B {
										private:
											// "has-a" relationship achieved using composition
											A objA;
										public:
											void func() {
												a = 10; <span style="color:red">// illegal</span>
												b = 20; <span style="color:red">// illegal</span>
												c = 30; <span style="color:red">// legal</span>
											}
									};
									
									// "has-a" relationship achieved using private inheritance
									class C : private A {
										public:
											void func() {
												a = 10; <span style="color:red">// illegal</span>
												b = 20; <span style="color:red">// legal</span>
												c = 30; <span style="color:red">// legal</span>
											}
									};
									int main() {
										A obj1;
										B obj2;
										C obj3
										return 0;
									}
								</pre>
								<br/>
								From the above, we can see that the accessibility of A's data members is not the same in composition and private inheritance.
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 14 March 2016 (Monday)<br/><br/><span style="text-decoration:underline">Private constructor and inheritance</span></div><br/>
								We have shown that private constructor could be defined in class to prevent the access from places other than member functions of the same class. With inhertiance, we should take note of the following case as well.
								<br/><br/>
								<pre style="margin-left: -500px">
									1:  #include &lt;iostream&gt;
									2:  using namespace std;
									3:
									4:  class A {
									5:	 protected:
									6:		int a;
									7:	 private:
									8:		A() { cout << "Default constructor of A"; }
									9:  };
									10:
									11: class B : public A {
									12:	public:
									13:		<span style="color:red">// Member initialization list : A() is inserted to constructor of B</span>
									14:		B() { cout << "Default constructor of B"; }
									15: };
									16:
									17: int main() {
									18:	B obj;
									19:	return 0;
									20: }
								</pre>
								This program has compilation error as follows:<br/><br/>
								<pre style="margin-left: -500px">
									privateconst.cpp: In constructor "B::B()":
									privateconst.cpp:8: error: "A::A()" is private
									privateconst.cpp:14: error: within this context
								</pre>
								The error is due to the invalid call of privae default constructor of A.
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>
					 <div id="tabs-7">					 
					 <h4 style="color:darkred; font-weight:bold">Runtime checking</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 16 March 2017 (Saturday)<br/><br/><span style="text-decoration:underline">Runtime type checking (virtual function) (More)</span></div><br/>
								The following example shows exactly the same program as the one below, except that a virtual keyword is put in front of the print() member function. So the type determined by RTTI is correct.
								<br/><br/>
								<pre style="margin-left:-500px">
									#include &lt;iostream&gt;
									using namespace std;
									
									class A {
										private:
											int a;
										public:
											A(int a = 0) { this->a = a; }
											// virtual
											virtual void print() { cout << "Value of a = " << a << endl; }
									};
									
									class B : public A {
										private:
											int b;
										public:
											B(int a, int b) : A(a) { this->b = b; }
											void print() { A::print(); cout << "Value of b = " << b << endl;  }
									};
									
									int main() {
										A* aPtr = new B(1,2);
										aPtr->print();
										cout << "The type of object pointed by aPtr is " << typeid(*aPtr).name() << endl;
										return 0;
									}
									
									Output:
									=======
									Value of a = 1
									Value of b = 2
									The type of object pointed by aPtr is 1B
								</pre>								
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 16 March 2017 (Saturday)<br/><br/><span style="text-decoration:underline">Runtime type checking (virtual function)</span></div><br/>
								The following example demonstrates RTTI doesn't work if there is no virtual function in the base class.								
								<br/><br/>
								<pre style="margin-left:-500px">
									#include &lt;iostream&gt;
									using namespace std;
									
									class A {
										private:
											int a;
										public:
											A(int a = 0) { this->a = a; }
											// not virtual
											void print() { cout << "Value of a = " << a << endl; }
									};
									
									class B : public A {
										private:
											int b;
										public:
											B(int a, int b) : A(a) { this->b = b; }
											void print() { A::print(); cout << "Value of b = " << b << endl;  }
									};
									
									int main() {
										A* aPtr = new B(1,2);
										aPtr->print();
										cout << "The type of object pointed by aPtr is " << typeid(*aPtr).name() << endl;
										return 0;
									}
									
									Output:
									=======
									Value of a = 1
									The type of object pointed by aPtr is 1A
								</pre>						
								Because of that, the type determined by RTTI is wrong.
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 19 March 2016 (Saturday)<br/><br/><span style="text-decoration:underline">Runtime type checking</span></div><br/>
								Based on the version of g++ we are using, it seems like the prefix value in the output of typeid function is the number of characters in the typename.
								Please refer to the following for example for details:
								<br/><br/>
								<pre style="margin-left:-500px">
									#include &lt;iostream&gt;
									#include &lt;string&gt;
									using namespace std;
									
									class Haha {
										public:
											Haha() {}
									};
									
									int main() {
										Haha obj;
										string str = typeid(obj).name();
										cout << str << endl;
										return 0;
									}
									
									Output:
									=======
									4Haha
								</pre>						
								Here, 4 means there are 4 characters in the typename Haha.
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>					 
					 <div id="tabs-8">
					 <h4 style="color:darkred; font-weight:bold">Virtual functions and polymorphism</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 20 March 2016 (Sunday)<br/><br/><span style="text-decoration:underline">Why constructors cannot be virtual?</span></div><br/>
								A virtual call is a mechanism to get work done given partial information. In particular, "virtual" allows us to call a function knowing only any interfaces and not the exact type of the object. To create an object you need complete information. In particular, you need to know the exact type of what you want to create. Consequently, a "call to a constructor" cannot be virtual.
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 19 March 2016 (Saturday)<br/><br/><span style="text-decoration:underline">Virtual destructor</span></div><br/>
								As mentioned in class, if there is no virtual keyword in base class destructor, it essentially means we are not supposed to do inheritance from that class. To illustrate why, please read the example below:
								<br/><br/>
								<pre style="margin-left:-500px">
									class A {
										private:
											int* p;
										public:
											A() {
												p = new int[100];
											}
											~A() {	<span style="color:red">// No virtual keyword here</span>
												if(p != NULL)
													delete [] p;
											}
									};
									
									class B : public A {
										private:
											int* q;
										public:
											B() : A() {
												q = new int[200];
											}
											~B() {
												if(q != NULL)
													delete [] q;
											}											
									};
									
									int main() {										
										A* ptr = new B;	<span style="color:red">// Statement A</span>
										// ...
										delete ptr;	<span style="color:red">// Statement B</span>
										return 0;
									}
								</pre>
								<br/>
								<ul>
									<li>Statement A:
										<ul>
											<li>new B;<br/>
												<ol>
													<li>Go to B()</li>
													<li>Go to A()</li>
													<li>Pointer variable p is created</li>
													<li>Enter the function body of A() and an array of 100 integer variables is allocated and pointed by p</li>
													<li>Back to B()</li>
													<li>Pointer variable q is created</li>
													<li>Enter the function body of B() and an array of 200 integer variables is allocated and pointed by q</li>
												</ol>
											</li>
											<li>A* ptr = new B; // Address of B type object is stored in the A type pointer ptr (Polymorphic Substitution Principle)</li>
										</ul>										
										<br/>
									</li>
									<li>Statement B:
										<ul>
											<li>delete ptr;<br/>
												<ol>
													<li>Go to ~A() // Since type of ptr is A</li>
													<li>No virtual keyword at ~A(), therefore ~A() is invoked</li>
													<li>As ~A() is involed, the dynamic array pointed by p is de-allocated</li>
												</ol>
											</li>
										</ul>
									</li>
								</ul>
								<br/>
								Note that as destructor of B (i.e. ~B()) is not called, the dynamic array pointed by q is not de-allocated and so resulted with memory leakage.
								<br/><br/>
								From this example, you should be able to observe one thing. If destructor of the base class is not being made as a virtual function, destructor of the derived class will not be called even with the support of 
								polymorphic substitution principle (i.e. A* ptr = new B;), which could cause memory leakage problem.
								<br/><br/>
								So this explains why we say that if the base class destructor is not virtual,
								the author of the base class does not expect people to use the class as a base class.
								<br/>
								<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>
					 <div id="tabs-9">
					 <h4 style="color:darkred; font-weight:bold">Abstract Base Class (ABC)</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 19 March 2016 (Saturday)<br/><br/><span style="text-decoration:underline">Abstract Base Classes (ABCs)</span></div><br/>
								As mentioned, ABCs are classes with one or more member functions that do not have implementation ( not even {} ). To avoid getting complaints from C++ because of that, we need to put = 0; after the function signature as follows:
								<br/><br/>
								<pre style="margin-left:-500px">
									class A {
										public:
											void f() { }
											// func() has no implementation and with = 0 at the end
											virtual void func() = 0;
									};
								</pre>								
								According to the definition of ABCs, A is an ABC. The following recaps a couple of important points about ABC:
								<br/><br/>
								<ol>
									<li>No object of type ABC can be constructed<br/>e.g. A obj; // Illegal</li>
									<li>Declaration of pointer and reference variables in ABC type is allowed.<br/>e.g. A* p;  // ok<br/>A& cool = ...;  // ok
									</li>
								</ol>
								<br/>
								<pre style="margin-left:-500px">
									class B : public A {
										public:
											// Function overriding
											// Also, func() is a virtual function as well
											void func() {
												...
											}
									};
									
									int main() {
										B obj;
										// Declaration of reference variable in ABC type
										// is okay and it accepts object in derived type 
										// (Polymorphic Substitution Principle)
										A& haha = obj;
										return 0;
									}
								</pre>
								<br/>
								From this, you can see that declaring reference variables in ABC type is somehow useful because of Polymorphic Substitution Principle. :-)
								Another interesting scenario is what if a class inherits an ABC, but do not override those functions without implementation. Then I have to say the new class is also an ABC.
								<br/><br/>
								Example:
								<br/><br/>
								<pre style="margin-left:-500px">
									class C : public A {
										public:
											void doSomething() {...}
											// void func() is inherited, but no overriding
									};
								</pre>
								<br/>
								As no overriding is done, class C is also an ABC.
								<br/><br/>
								Finally, I would like to introduce you the formal name of member functions with = 0 at the end. We call them “Pure Virtual Functions”. With this term, we could redefine ABCs as:
								<br/><br/>
								"Abstract Base Classes are classes with one or more pure virtual functions"
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
							</li>		
						</ul>
					 </p>
					 </div>
					 <div id="tabs-10">
					 <h4 style="color:darkred; font-weight:bold">Type casting</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 16 March 2017 (Thursday)<br/><br/><span style="text-decoration:underline">dynamic_cast (more)</span></div><br/>
								The following shows exactly the same program as the one below, except that a virtual keyword is put in the front of the print() member function. So that the program compiles.
								<br/><br/>
								<pre style="margin-left:-500px">
									#include &lt;iostream&gt;
									using namespace std;

									class A {
										private:
											int a;
										public:
											A(int a) { this->a = a; }
											virtual void print() {
												cout << "The value of a is " << a << endl;
											}
									};
									
									class B : public A {
										private:
											int b;
										public:
											B(int a, int b) : A(a) { this->b = b; }
											void print() {
												A::print();
												cout << "The value of b is " << b << endl;
											}
									};
									
									int main() {
										A objA(1);
										B objB(2,3);
										A* aPtr1 = &objB;
										B* bPtr1 = dynamic_cast&lt;B*&gt;(aPtr1); <span style="color:red">// valid and it returns non-NULL</span>
										if(bPtr1 != NULL)
											cout << "Conversion: dynamic_cast&lt;B*&gt;(aPtr1) is done successfully" << endl; <span style="color:red">This is executed</span>
										else
											cout << "Conversion: dynamic_cast&lt;B*&gt;(aPtr1) is failed" << endl;
										A* aPtr2 = &objA;
										B* bPtr2 = dynamic_cast&lt;B*&gt;(aPtr2); <span style="color:red">// In valid and it returns NULL</span>
										if(bPtr2 != NULL)
											cout << "Conversion: dynamic_cast&lt;B*&gt;(aPtr2) is done successfully" << endl;
										else
											cout << "Conversion: dynamic_cast&lt;B*&gt;(aPtr2) is failed" << endl; <span style="color:red">// This is executed</span>
										return 0;
									}
								</pre>
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 16 March 2017 (Thursday)<br/><br/><span style="text-decoration:underline">dynamic_cast</span></div><br/>
								Please note that dynamic_cast doesn't work if there is no virtual function in the base class. In other words, we are going to get compilation error for such a program. The following shows an example:
								<br/><br/>
								<pre style="margin-left:-500px">
									#include &lt;iostream&gt;
									using namespace std;

									class A {
										private:
											int a;
										public:
											A(int a) { this->a = a; }
											void print() {
												cout << "The value of a is " << a << endl;
											}
									};
									
									class B : public A {
										private:
											int b;
										public:
											B(int a, int b) : A(a) { this->b = b; }
											void print() {
												A::print();
												cout << "The value of b is " << b << endl;
											}
									};
									
									int main() {
										A objA(1);
										B objB(2,3);
										A* aPtr1 = &objB;
										B* bPtr1 = dynamic_cast&lt;B*&gt;(aPtr1); <span style="color:red">// error</span>
										if(bPtr1 != NULL)
											cout << "Conversion: dynamic_cast&lt;B*&gt;(aPtr1) is done successfully" << endl;
										else
											cout << "Conversion: dynamic_cast&lt;B*&gt;(aPtr1) is failed" << endl;
										A* aPtr2 = &objA;
										B* bPtr2 = dynamic_cast&lt;B*&gt;(aPtr2); <span style="color:red">// error</span>
										if(bPtr2 != NULL)
											cout << "Conversion: dynamic_cast&lt;B*&gt;(aPtr2) is done successfully" << endl;
										else
											cout << "Conversion: dynamic_cast&lt;B*&gt;(aPtr2) is failed" << endl;
										return 0;
									}
								</pre>
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 29 February 2016 (Monday)<br/><br/><span style="text-decoration:underline">Type casting operators</span></div><br/>
								We have seen a couple of type casting operators in C++, e.g.,
								<ul>
									<li>static_cast: Page 15 of the lecture notes on "Makefile and const-ness"</li>
									<li>reinterpret_cast: Page 19, 21 of the lecture notes on "Constructors and destructor"</li>
								</ul>
								<br/>
								In fact, there are 4 commonly used type casting operators in C++. The following provides some details of each type.
								<br/><br/>
								<table>
									<tr>
										<th>Casting Operator</th>
										<th>Description</th>								
									</tr>
									<tr>
										<td>static_cast</td>
										<td>Convert non-polymorphic types</td>
									</tr>
									<tr>
										<td>const_cast</td>
										<td>Add or remove the const-ness / volatile type</td>
									</tr>
									<tr>
										<td>dynamic_cast</td>
										<td>Convert polymorphic types</td>
									</tr>
									<tr>
										<td>reinterpret_cast</td>
										<td>For conversion of un-related types</td>
									</tr>
								</table>
								<br/>
								<div style="border:1px; outline-style: dotted; outline-color:gray; padding:5px">
									Syntax:<br/><br/>
									[ casting operator ]&lt;new type&gt; (expression)<br/><br/>
									where<br/>
									<ul>
										<li>[ casting operator ] could be any one in the list above, i.e. static_cast, const_cast, dynamic_cast, reinterpret_cast</li>
										<li>&lt;new type&gt; is the type after conversion</li>
										<li>expression is the "expression" to be converted</li>
									</ul>
								</div>
								<br/><br/>								
								<ul>
									<li>static_cast
										<ul>
											<li>It supports conversions which the compiler can check.</li>
											<li>It can cast a pointer of a derived class to its base class, and a pointer of a base class to its derived class (<span style="color:red">not always safe</span>).
												<br/>
												<span style="color:darkred; outline-style: dotted;">&nbsp;&nbsp;&nbsp;MORE DETAILS ON THIS when we talk about inheritance&nbsp;&nbsp;&nbsp;</span>
											</li>
											<li>It can convert int to enum type.</li>											
											<li>It is similar to dynamic_cast, except that <span style="color:red">no runtime checking</span> is performed.</li>
											<li>CANNOT
												<ul>
													<li>It cannot cast a pointer to a non-pointer</li>
													<li>It cannot remove const-ness / volatile-ness</li>
												</ul>
											</li>
										</ul>
										<br/>
										Example 1:
										<pre style="margin-left:-550px">
											#include &lt;iostream&gt;
											using namespace std;
											
											int main() {
												int total = 50;
												int no = 20;
												double average = total / no;
												cout << "Before: " << average << endl;
												average = static_cast&lt;double&gt;(total)/no;
												cout << "After: " << average << endl;
												return 0;
											}
										</pre>										
										<pre style="margin-left:-550px">
											Output:
												Before: 2
												After: 2.5
										</pre>										
										Example 2:
										<pre style="margin-left:-550px">
											#include &lt;iostream&gt;
											using namespace std;
											enum Season { Spring, Summer, Autumn, Winter };
											
											int main() {
												int a = 1;
												cout << "Integer a = " << a << endl;
												Season s = static_cast&lt;Season&gt;(a);
												cout << "enum a = " << s << endl;
												return 0;
											}
											
											Output:<br/>
												Integer a = 1
												enum a = 1
										</pre>										
										Example 3:<br/><br/><span style="color:darkred; outline-style: dotted;">&nbsp;&nbsp;&nbsp;MORE DETAILS ON THIS when we talk about inheritance&nbsp;&nbsp;&nbsp;</span>
										<br/><br/>
										<pre style="margin-left:-550px">
											class Base { };
											class Derived : public Base { };
											
											int main() {
												Base* b = new B;
												Derived* d = static_cast&lt;Derived*&gt;(b); <span style="color:red">// Unsafe</span>
												return 0;
											}
										</pre>										
									</li>
									<li>const_cast
										<ul>
											<li>It adds or removes the const-ness or volatile-ness of the expression.</li>
											<li>Note that the type after conversion should be the same as the original type EXCEPT adding or removing the const / volatile modifier.</li>
										</ul>
										<br/><br/>
										Example 1:
										<pre style="margin-left:-550px">
											#include &lt;iostream&gt;
											using namespace std;											
											
											void func(int& p) {
												//...
											}
											
											int main() {
												const int a = 50;
												func(a); <span style="color:red">// Error</span>
												func(const_cast&lt;int&&gt;(a));
												return 0;
											}
										</pre>
										Example 2:
										<pre style="margin-left:-550px">
											#include &lt;iostream&gt;
											#include &lt;string&gt;
											using namespace std;											
											
											class Person {
												private:
													string name;													
												public:
													// Constant member function
													void func() const {
														const_cast&lt;Person*&gt;(this)->name = "Haha";
													}
													string getName() const {
														return name;
													}
											};
																						
											int main() {
												Person p;
												p.func();
												cout << p.getName() << endl;
												return 0;
											}
										</pre>										
										<pre style="margin-left:-550px">
											Output:
												Haha
										</pre>
									</li>
									<li>dynamic_cast
										<ul>
											<li>The conversion is <span style="color:red">exclusively used with pointers and references to objects</span>.</li>
											<li>It could be used to cast from a derived class pointer to a base class pointer, cast a derived class pointer to another derived (sibling) class point or
											cast a base class pointer to a derived class pointer.<br/>
											<span style="color:darkred; outline-style: dotted;">&nbsp;&nbsp;&nbsp;MORE DETAILS ON THIS when we talk about inheritance&nbsp;&nbsp;&nbsp;</span>
											</li>
											<li>It <span style="color:red">performs runtime checking</span>. If the conversion cannot be done, NULL will be returned</li>
										</ul>
										<br/>
										Example:<br/><br/>
										<span style="color:darkred; outline-style: dotted;">&nbsp;&nbsp;&nbsp;MORE DETAILS ON THIS when we talk about inheritance&nbsp;&nbsp;&nbsp;</span>
										<br/><br/>
										<pre style="margin-left:-550px">
											#include &lt;iostream&gt;
											using namespace std;											
											
											class Base {};
											class Derived : public Base {};
											class DerivedDerived : public Derived {};
																						
											int main() {
												DerivedDerived* a = new DerivedDerived;
												
												Derived* b = dynamic_cast&lt;Derived*&gt;(a);
												if(b != NULL)
													cout << "Conversion is done successfully!" << endl;
												else
													cout << "Failed" << endl;
												
												Base* c = dynamic_cast&lt;Derived*&gt;(a);
												if(b != NULL)
													cout << "Conversion is done successfully!" << endl;
												else
													cout << "Failed" << endl;
												return 0;
											}
											
											Output:
												Conversion is done successfully!
												Conversion is done successfully!
										</pre>
									</li>
									<li>reinterpret_cast
										<ul>
											<li>It performs conversions between unrelated pointer types / references types.</li>
											<li>It also converts any integral type to any pointer type or converts any pointer type to integral type.</li>
											<li>Because of the unrelated conversion could be done, it can be <span style="color:red">unsafe if we do not use it properly</span>.</li>
										</ul>
										<br/>
										Example 1:
										<pre style="margin-left:-550px">
											#include &lt;iostream&gt;
											using namespace std;
											
											int main() {
												int a = 10;
												double* p = reinterpret_cast&lt;char*&gt;(a);
												return 0;
											}
										</pre>
										Example 2:
										<pre style="margin-left:-550px">
											#include &lt;iostream&gt;
											using namespace std;
											
											class A { };
											class B { };
											
											int main() {
												A* a = new A;
												B* b = reinterpret_cast&lt;B*&gt;(a);												
												return 0;
											}
										</pre>										
									</li>
								</ul>
								Final note:<br/><br/>
								We should always try to avoid using reinterpret_cast if possible. reinterpret_cast is really the last solution.
								<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>
					 <div id="tabs-11">
					 <h4 style="color:darkred; font-weight:bold">Operator overloading</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 28 March 2018 (Wednesday)<br/><br/><span style="text-decoration:underline">
							Why can't we simply return reference for operator+=, but returning const reference?
							</span></div><br/>
							The reason why we do return-by-const-reference is that we want to avoid the following occurs.
							<br/><br/>
							<pre style="margin-left:-400px">
							Vector a, b, c;
							(a += b) += c;  // Prevent this from happening
							</pre>
							In the expression (a += b) += c, a += b is evaluated first and so "a" is returned by const-reference. As it is a const-reference, the second call of operator+=, i.e. a += c, cannot be performed.<br/>
							(const reference can only call const member function, but operator+= is not).<br/><br/>
							So, by making return-by-const-reference can efficiently prevent programmers doing (a += b) += c;
							<br/>
							<br/>
							Please refer to the following for a program demonstrating the above.
							<br/><br/>
							<pre style="margin-left:-400px">
							#include &lt;iostream&gt;
							using namespace std;
							class Vector {
								private:
									double x, y;
								public:
									Vector(double x = 10, double y = 20) : x(x), y(y) { }
									const Vector& operator+=(const Vector& b) {      
										x += b.x;
										y += b.y;
										return *this;

									}
							};
							
							int main() {
								Vector a(1, 2);
								Vector b(3, 4);
								Vector c(5, 6);
								<span style="color:red">(a += b) += c; // ERROR</span>
							}
							</pre>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							
							<li><div style="font-weight: 500;">Date: 28 March 2018 (Wednesday)<br/><br/><span style="text-decoration:underline">
							As mentioned in class, we could define two versions of operator+ in our program, namely member operator+ and global operator+. Also, we know that the member operator+ will be called by default (if no conversion needs to be done). The question here is "can we force C++ to invoke global operator+ instead?"
							</span></div><br/>
							Yes. We can. Please refer to the following on how to do it.
							<br/><br/>							
							<pre style="margin-left:-400px">
							#include &lt;iostream&gt;
							using namespace std;
							class Vector {
								public:
									Vector(double x = 10, double y = 20) { }
									Vector operator+(const Vector& b) {
										cout << "Member" << endl;
										return Vector(); // dummy
									}
							};
								
							Vector operator+(const Vector& a, const Vector& b) {
								cout << "Global" << endl;
								return Vector(); // dummy
							}
								
							int main() {
								Vector a(1, 2);
								Vector b(3, 4);
								Vector c = a + b; // By default, member function operator+ is called
								<span style="color:red">Vector d = ::operator+(a, b); // With ::, we can call the global operator+</span>
							}
							</pre>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							
							<li><div style="font-weight: 500;">Date: 28 March 2018 (Wednesday)<br/><br/><span style="text-decoration:underline">
							Why don't we do return-by-reference for operator+?
							</span></div><br/>
							There are two reasons why we don’t do it.<br/><br/>
							<ol>
								<li>The resulting object is a new thing. ;)</li>
								<li>We use unnamed temporary object to store the result, and the temporary object will be removed in short time frame. So, mechanism that initializes copying is needed. Thus, return-by-value.</li>
							</ol>
							<br/>
							Please refer to the following for an example:
							<br/><br/>							
							<pre style="margin-left:-400px">
							#include &lt;iostream&gt;
							using namespace std;
							class Vector {
								private:
									double x, y;
								public:
									Vector(double x = 10, double y = 20) : x(x), y(y) { }
									double getX() const { return x; }
									double getY() const { return y; }
									void print() const {
										cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")" << endl;
									}
							};
							
							Vector operator+(const Vector& a, const Vector& b) {
								// We return the result by value, NOT by reference since
								// 1. The resulting object is a new thing
								// 2. The unnamed temporary object is created for storing the result,
								//    and it will be removed soon. So, we need to do copying in order to avoid dangling.
								return <span style="color:red">Vector(a.getX() + b.getX(), a.getY() + b.getY());</span>
							}
							
							int main() {
								Vector a(1, 2);
								Vector b(3, 4);
								Vector c = a + b;
								c.print();
							}
							</pre>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							
							<li><div style="font-weight: 500;">Date: 19 October 2017 (Thursday)<br/><br/><span style="text-decoration:underline">
							How to overload operator++ as a non-member function?
							</span></div><br/>
							The following example gives you an idea on how to implement operator++ as a non-member function (i.e. global function).
							<br/><br/>
							<pre style="margin-left:-400px">
							#include &lt;iostream&gt;
							using namespace std;
							class A {
								private:
									int a;
								public:
									A(int a) { this->a = a; }
									friend A& operator++(A& obj);
									friend A operator++(A& obj, int);
									friend ostream& operator<<(ostream& os, const A& obj);
							};
							
							A& operator++(A& obj) {
								(obj.a)++;
								return obj;
							}
							
							A operator++(A& obj, int) {
								A temp(obj);
								(obj.a)++;
								return temp;
							}
							
							ostream& operator<<(ostream& os, const A& obj) {
								return (os << obj.a << endl);
							}
							
							int main() {
								A obj(10);
								obj++;
								cout << obj;
								++obj;
								cout << obj;
								return 0;
							}
							</pre>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 28 October 2016 (Friday)<br/><br/><span style="text-decoration:underline">
							Rules on Overloading Operators
							</span></div><br/>
							<ol>
								<li>List of operators that can only be overloaded as member functions:
								<ol type="i">
									<li>assignment operator =</li>
									<li>subscript operator []</li>
									<li>member access operator (arrow) -></li>
									<li>functional forms ()<br/><br/></li>
								</ol>		
								<li>List of operators that can only be overloaded as non-member functions:
								<ol type="i">
									<li>insertion operator &gt;&gt;</li>
									<li>extraction operator &lt;&lt;<br/><br/></li>
								</ol>
								<li>List of operators that cannot be overloaded:
								<ol type="i">
									<li>dot operator(.)</li>
									<li>scope resolution operator(::)</li>
									<li>sizeof</li>
									<li>conditional operator ?:</li>
									<li>access pointer .*<br/><br/></li>
								</ol>								
								<li>Cannot create a new operator</li>
								<li>Cannot change the number of arguments that an operator takes</li>
								<li>Cannot change the precedence of an operator</li>
								<li>An overloaded operator cannot have default arguments</li>
							</ol>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 7 April 2016 (Monday)<br/><br/><span style="text-decoration:underline">
							Ambiguous case of operator overloading
							</span></div><br/>
							The following shows an ambiguous case of operator overloading:
							<br/><br/>
							<pre style="margin-left:-450px">
								#include &lt;iostream&gt;
								using namespace std;
								class Vector2 {
									public:
										Vector2(double x) {
											cout &lt;&lt; "Vector 2" &lt;&lt; endl;
										}
								};
								class Vector {
									public:
										Vector(double x) {
											cout &lt;&lt; "Vector" << endl;
										}
										const Vector& operator+=(const Vector& b) {
											return *this;
										}
										const Vector& operator+=(const Vector2& b) {
											return *this;
										}
								};
								int main() {
									Vector a(1.0);
									
									// The following line causes compilation error.
									// Since, two operator functions:
									// operator+=(const Vector& b) and operator+=(const Vector2& b)
									// could be called with the support of conversion constructors:
									// Vector(double x) and Vector2(double x)
									a += 2.3;
									
									return 0;
								}
							</pre>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 29 February 2016 (Monday)<br/><br/><span style="text-decoration:underline">Assignment operator function</span></div><br/>
								We have mentioned a couple of times that assignment operator is indeed a member function. To show this, an example is given as follows:
								<br/><br/>
								<pre style="margin-left:-500px">
									#include &lt;iostream&gt;
									#include &lt;string&gt;
									using namespace std;

									class Student {
										private:
											string name;
											int age;
											char gender;
											int noCourses;
											int* marks;											
										public:
											Student(string n = "", int a = 0, char g = 'M', int no = 0) {
												name = n;
												age = a;
												gender = g;
												noCourses = no;
												marks = (noCourses &gt; 0) ? new int[noCourses] : NULL;
												cout << "Constructor is called" << endl;
											}
											<span style="color:red">// Copy constructor</span>
											<span style="color:red">// Performing deep copying</span>
											Student(const Student& s) {
												name = s.name;
												age = s.age;
												gender = s.gender;
												noCourses = s.noCourses;
												marks = (noCourses > 0) ? new int[noCourses] : NULL;
												for(int i=0; i&lt;noCourses; i++)
													marks[i] = s.marks[i];
											}
											~Student() {
												if(marks != NULL)
													delete [] marks;
												cout << "Destructor is called" << endl;
											}
											<span style="color:red">// Assignment operator function</span>
											<span style="color:red">// Performing deep copying</span>
											Student& operator=(const Student& s) {
												if(this != &s) {
													name = s.name;
													age = s.age;
													gender = s.gender;
													noCourses = s.noCourses;
													delete [] marks;
													marks = (noCourses > 0) ? new 	int[noCourses] : NULL;
													for(int i=0; i&lt;noCourses; i++)
														marks[i] = s.marks[i];
													cout << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
													cout << "Assignment operator function is called" << endl;
													cout << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
												}
												return *this;
											}
											void print() {
												cout << "Name: " << name << endl;
												cout << "Age: " << age << endl;  
												cout << "Gender: " << gender << endl;
												cout << "No of courses: " << noCourses << endl;
												if(noCourses > 0) {
													cout << "Course marks: ";
													for(int i=0; i&lt;noCourses; i++)
														cout << marks[i] << " ";
													cout << endl;
												}
											}
									};
									
									void testStudent() {
										Student firstStudent("Desmond", 18, 'M', 10);
										Student secondStudent("Brian", 20, 'M', 20);
										cout << "=================" << endl;
										cout << "Before assignment" << endl;
										cout << "=================" << endl;
										firstStudent.print();
										cout << "-----------------" << endl;
										secondStudent.print();         
										
										firstStudent = secondStudent;
										
										cout << "================" << endl;
										cout << "After assignment" << endl;
										cout << "================" << endl;
										firstStudent.print();
										cout << "-----------------" << endl;
										secondStudent.print();
									}
									
									int main() {
										testStudent();
										return 0;
									}
								</pre>
								Output:
								<pre style="margin-left:-500px">
									Constructor is called
									Constructor is called
									=================
									Before assignment
									=================
									Name: Desmond
									Age: 18
									Gender: M
									No of courses: 10
									Course marks: 0 0 0 0 0 0 0 0 0 0 
									-----------------
									Name: Brian
									Age: 20
									Gender: M
									No of courses: 20
									Course marks: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
									<span style="color:red">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
									<span style="color:red">Assignment operator function is called</span>
									<span style="color:red">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
									================
									After assignment
									================
									Name: Brian
									Age: 20
									Gender: M
									No of courses: 20
									Course marks: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
									-----------------
									Name: Brian
									Age: 20
									Gender: M
									No of courses: 20
									Course marks: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
									Destructor is called
									Destructor is called
								</pre>
								From the above, you can see that:
								<ol>
									<li>operator = is indeed a member function in C++</li>
									<li>The statement "firstStudent = secondStudent;" invokes the operator function.</li>
								</ol>
								<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>

					 <div id="tabs-16"> 
					 <h4 style="color:darkred; font-weight:bold">Function template and class template</h4><br/><br/>
					 <p>
						<ul>
							<li>
							<div style="font-weight: 500;">Date: 6 November 2016 (Sunday)<br/><br/><span style="text-decoration:underline">
							Template Specialization
							</span></div><br/>
							Template specialization is a C++ mechanism used to create a specialized version of template. To explain this idea, we use the following example.
							<br/><br/>
							Suppose we want to implement a function template that compares two values and see if they are equal. To make this happen, we typically use equality operator, ==, to do the job. However, == could only be applied on integral types (e.g. short, int, long, char, etc.), but not on floating point numbers. To remedy this, we define:
							<br/><br/>
							<ol>
								<li>A function template for all integral or equivalent types, and</li>
								<li>Two specialized versions, one for float and the other for double</li>
							</ol>
							<br/>
							as follows:
							<br/><br/>
							<pre style="margin-left:-450px">
								#include &lt;iostream&gt;
								#include &lt;cmath&gt;
								#include &lt;limits&gt;
								using namespace std;

								template &lt;typename T&gt; <span style="color:red">// general version for all integral or equivalent types</span>
								bool same(T a, T b) {
									cout << "version - general" << endl;
									return (a == b) ? true : false;
								}
								
								template &lt;&gt; <span style="color:red">// a specialized version of function template "same"</span>
								bool same&lt;float&gt;(float a, float b) { <span style="color:red">// version for float type</span>
									cout << "version - float" << endl;
									return (fabs(a - b) &lt; numeric_limits&lt;float&gt;::epsilon()) ? true : false;
								}
								
								template &lt;&gt; <span style="color:red">// a specialized version of function template "same"</span>
								bool same&lt;double&gt;(double a, double b) { <span style="color:red">// version for double type</span>
									cout << "version - double" << endl;
									return (fabs(a - b) &lt; numeric_limits&lt;double&gt;::epsilon()) ? true : false;
								}
								
								int main() {
									int a = 10, b = 20;
									float c = 21.6, d = 21.6;
									double e = 23.1, f = 23.1;
									
									if(same(a, b)) cout << "Same" << endl;
									else cout << "Different" << endl;

									if(same(c, d)) cout << "Same" << endl;
									else cout << "Different" << endl;
									
									if(same(e, f)) cout << "Same" << endl;
									else cout << "Different" << endl;
									
									return 0;
								}
							</pre>
							Output:
							<br/><br/>							
							<pre style="margin-left:-450px">
								version - general
								Different
								version - float
								Same
								version - double
								Same
							</pre>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>							
							</li>
							<li>
							<div style="font-weight: 500;">Date: 4 November 2016 (Friday)<br/><br/><span style="text-decoration:underline">
							Function Template
							</span></div><br/>							
							<pre style="margin-left:-450px">
								template &lt;int i&gt;
								void func() {
									i = 20;
								}
							</pre>
							Why the above is an error?
							<br/><br/>
							Non-type variable, i.e. int i in the template, would be made a constant. To initialize it, we could do the following:<br/><br/>
							<pre style="margin-left:-450px">
								int main() {
									func<10>();
									return 0;
								}
							</pre>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>							
							</li>
						</ul>
					 </p>
					 </div> 
					 
					 <div id="tabs-12">
					 <h4 style="color:darkred; font-weight:bold">Friend classes and friend functions</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 28 March 2016 (Wednesday)<br/><br/><span style="text-decoration:underline">
							How to specify a member function as a friend of a class?
							</span></div><br/>
							Please refer to the following for an example:<br/><br/>
							<pre style="margin-left:-450px">
								#include &lt;iostream&gt;
								using namespace std;
								
								class B;
								
								class A {
									public:
										// Needs to know about B, but does not need full definition. 
										// So, use forward declaration of B
										void haha(B& aRef);
								}; 
								
								class B { 
									private:
										int x;
										int y;
									public:
										B() : x(10), y(20) { }
										// B treats member function haha of A as friend
										friend void A::haha(B& aRef); // B needs the full definition of A
								};
								
								void A::haha(B& bRef) {
									cout &lt;&lt; "x is " &lt;&lt; bRef.x &lt;&lt; endl;
									cout &lt;&lt; "y is " &lt;&lt; bRef.y &lt;&lt; endl;
								} 
								
								int main() {
									A aObj;   
									B bObj;
									aObj.haha(bObj);
								}
							</pre>							
							<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>							
							</li>
						
						
						
						
							<li><div style="font-weight: 500;">Date: 7 April 2016 (Monday)<br/><br/><span style="text-decoration:underline">
							Base class as friend of derived class and derived class as friend of base class
							</span></div><br/>
							In terms of C++ syntax, it is legal to make a derived class as friend of a base class, and vice and versa. The following shows an example:<br/><br/>
							<pre style="margin-left:-450px">
								#include &lt;iostream&gt;
								using namespace std;

								class B;

								class A {
									private:
										int a;
										friend class B;
									public:
										void funcA(B& bRef);
								};
								
								class B : public A {
									private:
										int b;
										friend class A;
									public:
										void funcB(A& aRef);
								};
								
								void A::funcA(B& bRef) {
									bRef.b = 10;
									cout << "A::funcA" << endl;
								}
								
								void B::funcB(A& aRef) {
									aRef.a = 20;
									cout << "B::funcB" << endl;
								}
								
								int main() {
									A aObj;
									B bObj;
									aObj.funcA(bObj);
									bObj.funcB(aObj);
									return 0;
								}
							</pre>
							Although the above code is valid, it is not something we should do in general. First, a base class has no knowledge of its derived classes as the latter ones are not "born" yet. Second, the derived class has its base class "in its body" and may call its base class public / protected member functions, making the base class as a friend and as a parent seems odd.
							<br/><br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>							
							</li>
							<li><div style="font-weight: 500;">Date: 7 April 2016 (Monday)<br/><br/><span style="text-decoration:underline">
							Friend member functions
							</span></div><br/>
							Member functions could also be made as friend of a class. In other words, not only global functions could be friends of a class, but also member functions. Please refer to the following for an example:<br/><br/>
							<pre style="margin-left:-450px">
								class B;
								class A {
									public:
										int func1(B& b);
										int func2(B& b);
								};
								
								class B {
									private:
										int b;
										friend int A::func1(B& b);
								};
								
								// The access of private data member b is <span style="color:red">legal</span>
								int A::func1(B& bRef) { bRef.b = 10; }
								// The access of private data member b is <span style="color:red">illegal</span>
								int A::func2(B& bRef) { bRef.b = 20; }
								
								int main() {
									B bObj;
									A aObj;
									aObj.func1(bObj);
									return 0;
								}
							</pre>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 7 April 2016 (Monday)<br/><br/><span style="text-decoration:underline">
							Forward declaration
							</span></div><br/>
							Please note that forward declaration is <span style="color:red">NOT</span> required for friend class / function declaration. Please refer to the following for an example:<br/><br/>
							<pre style="margin-left:-450px">
								class A {
									friend class B;
									friend void func();
								};
							</pre>
							Note:<br/>
							<ul>
								<li>No forward declaration of class B is required for the statement "friend class B;"</li>
								<li>No forward declaration of the global function void func() is needed for the statement "friend void func();"</li>
							</ul>
							<br/>
								Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
								<hr/>
								<br/>
								<br/>
							</li>
						</ul>
					 </p>
					 </div>		 
					 <div id="tabs-13">
					 <h4 style="color:darkred; font-weight:bold">Standard Template Library</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 22 April 2016 (Friday)<br/><br/><span style="text-decoration:underline">
							transform algorithm
							</span></div><br/>
							As mentioned, the 3rd parameter of transform function should be an iterator pointing to the initial position of the result container where the processed results are stored. Please note that we have to make sure that the <span style="color:red">result container has enough space</span> to store all the processed results. If not, "segmentation fault" would occur.
							<br/><br/>
							For details, please refer to the example below.			
							<br/><br/>
							<pre style="margin-left:-450px">
								#include &lt;iostream&gt;								
								#include &lt;vector&gt;
								using namespace std;
								
								int addOne(int n) {
									return n + 1;
								}
								
								int main() {
									vector&lt;int&gt; v;
									vector&lt;int&gt; resultV;
									for(int i=0; i<10; i++)
										v.push_back(i+1);
										
									<span style="color:red">// Resize the result container to size exactly
									// the same as the input vector container</span>
									resultV.resize(v.size());
									
									vector&lt;int&gt;::iterator it = transform(v.begin(), v.end(), resultV.begin(), addOne);  
									
									for(vector&lt;int&gt;::iterator p = resultV.begin(); p != resultV.end(); p++)
									   cout << *p << " ";
									return 0;
								}
							</pre>
							<br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
						</ul>						
						</li>
					 </p>
					 </div>
					 
					 <div id="tabs-14">					 
					 <h4 style="color:darkred; font-weight:bold">Namespace</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 22 April 2016 (Friday)<br/><br/><span style="text-decoration:underline">
							Same namespace in different files
							</span></div><br/>
							Please note that we can split namespace into multiple files. For details, please refer to the example below:
							<br/><br/>
							<pre style="margin-left:-450px">
								// A.h
								namespace Haha
								{
									class A {
										// ...
									};
								}
								// B.h
								namespace Haha
								{
									class B {
										// ...
									};
								}
							</pre>
							<br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
						</ul>						
						</li>
					 </p>
					 </div>
					 <div id="tabs-15">
					 <h4 style="color:darkred; font-weight:bold">Static data members and member functions</h4><br/><br/>
					 <p>
						<ul>
							<li><div style="font-weight: 500;">Date: 25 April 2016 (Monday)<br/><br/><span style="text-decoration:underline">
							Named Constructor
							</span></div><br/>
							<pre style="margin-left:-400px">
							static Clock minutes(int m) {
								return Clock(hhmm/100, hhmm%100);
							}
							</pre>
							In the static function minutes, it invokes conversion constructor. However, the conversion constructor is not a static function. Why can it be called?
							<br/><br/>
							It is because constructor is an exceptional case, just like we could use Clock constructor in main, even main is not static.
							<br/><br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 25 April 2016 (Monday)<br/><br/><span style="text-decoration:underline">
							Static data members
							</span></div><br/>
							Please refer to the following for an example with global, local and static variables all with the same name.
							<br/><br/>
							<pre style="margin-left:-450px">
								#include &lt;iostream&gt;
								using namespace std;
								
								// Global variable a
								int a = 10;
								class A {
									private:
										// Static variable a
										static int a;
									public:
										void func1() {
											cout << "In func1()" << endl;
											cout << "==========" << endl;
											
											// Local variable a
											int a = 20;
											cout << "Local variable a: " << a << endl;
											::a = 30;
											cout << "Global variable a: " << ::a << endl;
											A::a = 40;
											cout << "Static variable a: " << A::a << endl;
										}

										void func2() {
											cout << "In func2()" << endl;
											cout << "==========" << endl;
											cout << "Global variable ::a: " << ::a << endl;
											cout << "Static variable a: " << a << endl;
											cout << "Static variable a: " << A::a << endl;
										}
								};
								
								int A::a = 1;
								
								int main() {
									A obj;
									obj.func1();
									obj.func2();
									cout << "In main()" << endl;
									cout << "=========" << endl;
									cout << "Global variable a: " << a << endl;
									cout << "Global variable ::a: " << ::a << endl;
									return 0;
								}
							</pre>
							Output:<br/><br/>
							<pre style="margin-left:-400px">
							In func1()
							==========
							Local variable a: 20
							Global variable a: 30
							Static variable a: 40
							In func2()
							==========
							Global variable ::a: 30
							Static variable a: 40
							Static variable a: 40
							In main()
							=========
							Global variable a: 30
							Global variable ::a: 30
							</pre>
							<br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
							<li><div style="font-weight: 500;">Date: 22 April 2016 (Friday)<br/><br/><span style="text-decoration:underline">
							Static data members
							</span></div><br/>
							Without the initialization of static data members outside the class, static data members will not be constructed / declared. Please refer to the following for an example:							
							<br/><br/>
							<pre style="margin-left:-450px">
								#include &lt;iostream&gt;
								using namespace std;
								class A {
									public:
										A() {
											cout << "A constructor" << endl;
										}
								};
								
								class B {
									private:
										// The following is a static data member:
										// a is not constructed at this point
										static int a;
										
										int b;
										
										// The following is a static data member:
										// c is not constructed at this point
										static A c; 
									public:
										void func() {
											cout << a << " " << b << endl;
										}
								};
								
								// The static data member: a is constructed at this 
								// point and initialized to 1
								int B::a = 1;
								
								// The static data member: c is constructed at this 
								// point and the constructor of A is called
								A B::c;

								int main() {
									B obj;
									// The following line prints 1 and a garbage value
									obj.func();
									// The following line results an error.
									// Since static variable a is declared in B as private
									B::a = 10;
									return 0;
								}
							</pre>
							<br/>
							Best,<br/>Desmond<br/>Instructor of COMP2012<br/><br/>
							<hr/>
							<br/>
							<br/>
							</li>
						</ul>						
						</li>
					 </p>
					 </div>
                  </div>
				  </div>
               </article>         
            </div>
            <div class="s-12 l-3">
               <aside>
				  <div class="aside-block margin-bottom">
                     <h3>Instructor</h3>					 
                     <ul>
						<li>Dr. Desmond TSOI</li>
						<li>E-mail: desmond (followed by cse.ust.hk)</li>
						<li>Office: Rm 3553<br/><a href="http://pathadvisor.ust.hk/interface.php?roomno=3553">Path Advisor</a></li>
					 </ul>
                  </div>
                  <div class="aside-block margin-bottom">
                     <h3>Course Desc.</h3>
                     <p>To learn the fundamental concepts and techniques behind object-oriented programming. They include: abstract data types; creation, initialization, and destruction of objects; class hierarchies; polymorphism, inheritance and dynamic binding; generic programming using templates. To learn the object-oriented view of data structures: linked lists, queues, stacks, trees, and algorithms such as searching and hashing algorithms.</p>
                  </div>                  
                  <div class="aside-block margin-bottom">
                     <h3>Lecture Time and Venue:</h3>
					 <ul>
						<li>L1: Every Tuesday and Thursday, from 12:00pm - 01:20pm on Zoom</li><br/>
						<li>L2: Every Wednesday and Friday, from 04:30pm - 05:50pm on Zoom</li><br/>
					 </ul>
                  </div>
				  <div class="aside-block margin-bottom">
                     <h3>Academic Calendar 2020/21</h3>
                     <a href="https://registry.ust.hk/calendar_dates/dates20-21confirmed.pdf">Click Here</a>
                  </div>				  
               </aside>
            </div>
         </div>
      </section>
      <div class="line">
         <footer>
            <div class="s-12 l-8">
               <p>
                  Copyright 2020, Desmond Tsoi<br>
                  All images on this page are from the Internet.
               </p>
            </div>            
         </footer>
      </div>
   </body>
</html>
